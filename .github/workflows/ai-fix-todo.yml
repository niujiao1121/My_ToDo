name: AI æ›´æ–° TODOï¼ˆ/fixï¼‰

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: read

jobs:
  ai-fix-todo:
    runs-on: ubuntu-latest

    concurrency:
      group: ai-fix-todo-${{ github.event.issue.number }}
      cancel-in-progress: true

    if: github.event_name == 'issue_comment' && contains(github.event.comment.body, '/fix')

    steps:
      - name: æ£€æŸ¥æƒé™
        id: check-permission
        uses: actions/github-script@v7
        with:
          script: |
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ˜¯ä»“åº“æˆå‘˜æˆ–åä½œè€…
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: context.actor
              });

              const hasPermission = ['admin', 'write', 'maintain'].includes(permission.permission);

              if (!hasPermission) {
                const issueNumber = context.payload.issue.number;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: 'âŒ æŠ±æ­‰ï¼Œåªæœ‰ä»“åº“æˆå‘˜å¯ä»¥ä½¿ç”¨ /fix å‘½ä»¤ã€‚'
                });
                core.setFailed('ç”¨æˆ·æ²¡æœ‰è¶³å¤Ÿçš„æƒé™');
              }

              return hasPermission;
            } catch (error) {
              core.error('æ£€æŸ¥æƒé™æ—¶å‡ºé”™ï¼š' + error.message);
              return false;
            }

      - name: å¤„ç† /fix å‘½ä»¤
        if: steps.check-permission.outputs.result == 'true'
        uses: actions/github-script@v7
        env:
          DASHSCOPE_API_KEY: ${{ secrets.DASHSCOPE_API_KEY }}
        with:
          script: |
            const https = require('https');

            const SYSTEM_LABELS = [
              'project', 'epic', 'task-with-deadline', 'task-open', 'subtask', 'ai-todo-inbox',
              'priority:critical', 'priority:high', 'priority:medium', 'priority:low',
              'status:planning', 'status:in-progress', 'status:blocked', 'status:review', 'status:testing',
              'type:feature', 'type:enhancement', 'type:bug', 'type:refactoring', 'type:documentation', 'type:research',
              'help-wanted', 'good-first-issue', 'duplicate', 'wontfix', 'archived'
            ];

            const stripTemplateSections = (text) => {
              if (!text) return '';

              let cleaned = text;
              const sectionPatterns = [
                /##\s*ğŸ“‹\s*ä»»åŠ¡æè¿°[\s\S]*?(?=(\n##|$))/gi,
                /##\s*â°\s*æ—¶é—´è¦æ±‚[\s\S]*?(?=(\n##|$))/gi,
                /##\s*âœ…\s*éªŒæ”¶æ ‡å‡†[\s\S]*?(?=(\n##|$))/gi,
                /##\s*ğŸ“\s*ä»»åŠ¡æ¸…å•[\s\S]*?(?=(\n##|$))/gi,
                /##\s*ğŸ¯\s*å®Œæˆæ¡ä»¶[\s\S]*?(?=(\n##|$))/gi,
                /##\s*ğŸ“\s*å®ç°æ€è·¯[\s\S]*?(?=(\n##|$))/gi,
                /##\s*ğŸ”—\s*çˆ¶ä»»åŠ¡[\s\S]*?(?=(\n##|$))/gi,
                /---\s*\n\n\*æ­¤ TODO ç”±é˜¿é‡Œäº‘ AI åŠ©æ‰‹[\s\S]*$/i,
                /\*æ­¤ TODO ç”±é˜¿é‡Œäº‘ AI åŠ©æ‰‹[\s\S]*$/i
              ];

              sectionPatterns.forEach((pattern) => {
                cleaned = cleaned.replace(pattern, '');
              });

              cleaned = cleaned
                .replace(/Parent Issue\s*[:ï¼š]\s*#?\d+/gi, '')
                .replace(/åŸå§‹è¾“å…¥æ¥è‡ª[:ï¼š]\s*#?\d+/gi, '')
                .replace(/å±äº#?\d+/gi, '')
                .replace(/å­ä»»åŠ¡\s*#?\d+/gi, '')
                .replace(/\n{3,}/g, '\n\n')
                .trim();

              return cleaned;
            };

            const dedupeList = (list) => {
              if (!Array.isArray(list)) return [];
              const seen = new Set();
              const result = [];
              list.forEach((item) => {
                const normalized = (item || '').trim();
                if (!normalized) return;
                if (seen.has(normalized)) return;
                seen.add(normalized);
                result.push(normalized);
              });
              return result;
            };

            const buildIssueBodyFromParsedData = (parsedData, sourceIssueNumber) => {
              const parentIssueSection = parsedData.parent_issue
                ? '\n\n## ğŸ”— çˆ¶ä»»åŠ¡\n\n**Parent Issue**: #' + parsedData.parent_issue
                : '';

              const sanitizedDescription = stripTemplateSections(parsedData.description) || 'å¾…è¡¥å……';

              if (parsedData.task_type === 'deadline') {
                const acceptanceCriteria = dedupeList(parsedData.acceptance_criteria);
                const taskChecklist = dedupeList(parsedData.task_checklist);

                const acceptanceContent = acceptanceCriteria.length > 0
                  ? acceptanceCriteria.map(c => '- [ ] ' + c).join('\n')
                  : '- [ ] å¾…è¡¥å……';
                const checklistContent = taskChecklist.length > 0
                  ? taskChecklist.map(t => '- [ ] ' + t).join('\n')
                  : '- [ ] å¾…è¡¥å……';

                return '## ğŸ“‹ ä»»åŠ¡æè¿°\n\n' + sanitizedDescription + parentIssueSection + '\n\n' +
                  '## â° æ—¶é—´è¦æ±‚\n\n' +
                  '**æˆªæ­¢æ—¥æœŸ**: ' + (parsedData.due_date || 'å¾…å®š') + ' â°\n' +
                  '**é¢„è®¡å·¥ä½œé‡**: ' + (parsedData.estimated_hours || 'å¾…è¯„ä¼°') + 'å°æ—¶\n\n' +
                  '## âœ… éªŒæ”¶æ ‡å‡†\n\n' + acceptanceContent + '\n\n' +
                  '## ğŸ“ ä»»åŠ¡æ¸…å•\n\n' + checklistContent + '\n\n' +
                  '---\n\n' +
                  '*æ­¤ TODO ç”±é˜¿é‡Œäº‘ AI åŠ©æ‰‹ç”Ÿæˆ/æ›´æ–°*\n' +
                  '*åŸå§‹è¾“å…¥æ¥è‡ª: #' + sourceIssueNumber + '*';
              }

              const acceptanceCriteria = dedupeList(parsedData.acceptance_criteria);
              const taskChecklist = dedupeList(parsedData.task_checklist);

              const acceptanceContent = acceptanceCriteria.length > 0
                ? acceptanceCriteria.map(c => '- [ ] ' + c).join('\n')
                : '- [ ] å¾…è¡¥å……';
              const checklistContent = taskChecklist.length > 0
                ? taskChecklist.map((t, i) => (i + 1) + '. ' + t).join('\n')
                : 'å¾…è¡¥å……';

              return '## ğŸ“‹ ä»»åŠ¡æè¿°\n\n' + sanitizedDescription + parentIssueSection + '\n\n' +
                '## ğŸ¯ å®Œæˆæ¡ä»¶\n\n' +
                '**é¢„è®¡å·¥ä½œé‡**: ' + (parsedData.estimated_hours || 'å¾…è¯„ä¼°') + 'å°æ—¶\n\n' +
                '**éªŒæ”¶æ ‡å‡†**: \n' + acceptanceContent + '\n\n' +
                '## ğŸ“ å®ç°æ€è·¯\n\n' + checklistContent + '\n\n' +
                '---\n\n' +
                '*æ­¤ TODO ç”±é˜¿é‡Œäº‘ AI åŠ©æ‰‹ç”Ÿæˆ/æ›´æ–°*\n' +
                '*åŸå§‹è¾“å…¥æ¥è‡ª: #' + sourceIssueNumber + '*';
            };

            const comment = (context.payload.comment.body || '').trim();
            const fixMatch = comment.match(/^\/fix\s+([\s\S]+)/im);

            if (!fixMatch || !fixMatch[1].trim()) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: 'âŒ /fix æŒ‡ä»¤åéœ€è¦æä¾›ä¿®æ”¹è¯´æ˜ã€‚'
              });
              return;
            }

            if (!process.env.DASHSCOPE_API_KEY) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: 'âŒ é˜¿é‡Œäº‘ API Key æœªé…ç½®ã€‚è¯·åœ¨ä»“åº“çš„ Secrets ä¸­æ·»åŠ  `DASHSCOPE_API_KEY`ã€‚\n\né…ç½®æ­¥éª¤ï¼šhttps://github.com/' + context.repo.owner + '/' + context.repo.repo + '/blob/main/docs/AI_SETUP.md'
              });
              return;
            }

            const fixPrompt = fixMatch[1].trim();
            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const currentLabels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
            const currentPriorityLabel = currentLabels.find(l => l.startsWith('priority:'));
            const currentPriority = currentPriorityLabel ? currentPriorityLabel.split(':')[1] : 'medium';
            const currentTaskType = currentLabels.includes('task-with-deadline') ? 'deadline' : 'open';
            const currentBody = issue.body || '';
            const currentDueMatch = currentBody.match(/æˆªæ­¢æ—¥æœŸ\*\*:\s*([0-9]{4}-[0-9]{2}-[0-9]{2}|å¾…å®š)/);
            const currentDue = currentDueMatch && currentDueMatch[1] !== 'å¾…å®š' ? currentDueMatch[1] : null;
            const parentMatch = currentBody.match(/Parent Issue\*\*:\s*#(\d+)/i) || currentBody.match(/åŸå§‹è¾“å…¥æ¥è‡ª[:ï¼š]?\s*#(\d+)/i) || currentBody.match(/å±äº#?(\d+)/i);
            const currentParent = parentMatch ? parentMatch[1] : null;

            const fixSystemPrompt = 'ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ TODO ç»´æŠ¤åŠ©æ‰‹ã€‚æ ¹æ®ç”¨æˆ·æä¾›çš„ä¿®æ”¹æŒ‡ä»¤å’Œå½“å‰ TODO å†…å®¹ï¼Œè¿”å›æ›´æ–°åçš„ç»“æ„åŒ–æ•°æ®ã€‚' +
              'å¦‚æœç”¨æˆ·æ²¡æœ‰æ˜ç¡®ä¿®æ”¹æŸä¸ªå­—æ®µï¼Œè¯·ä¿ç•™å½“å‰å€¼ã€‚ç¡®ä¿è¾“å‡ºå­—æ®µéµå¾ªä»¥ä¸‹æ ¼å¼ï¼š\n' +
              '{\n' +
              '  "title": "æ›´æ–°åçš„æ ‡é¢˜",\n' +
              '  "description": "æ›´æ–°åçš„ä»»åŠ¡æè¿°ï¼Œä¿ç•™å…³é”®èƒŒæ™¯ä¿¡æ¯",\n' +
              '  "parent_issue": "çˆ¶ä»»åŠ¡ç¼–å·æˆ– null",\n' +
              '  "due_date": "YYYY-MM-DD æˆ– null",\n' +
              '  "priority": "critical/high/medium/low",\n' +
              '  "estimated_hours": "é¢„è®¡å·¥æ—¶ï¼Œä¿ç•™æˆ–æŒ‰éœ€æ±‚è°ƒæ•´",\n' +
              '  "acceptance_criteria": ["éªŒæ”¶æ ‡å‡†1", "éªŒæ”¶æ ‡å‡†2"],\n' +
              '  "task_checklist": ["æ­¥éª¤1", "æ­¥éª¤2"],\n' +
              '  "task_type": "deadline æˆ– openï¼ŒåŸºäºæ˜¯å¦æœ‰æˆªæ­¢æ—¥æœŸ"\n' +
              '}\n' +
              'éœ€è¦ç¡®ä¿æˆªæ­¢æ—¶é—´ã€çˆ¶å­ä»»åŠ¡å…³ç³»ç­‰ä¿¡æ¯æ ¼å¼ç¬¦åˆå½“å‰ä»“åº“çš„æƒ¯ä¾‹ã€‚åªè¿”å› JSONï¼Œä¸è¦åŒ…å«å…¶ä»–æ–‡å­—ã€‚';

            const fixUserPrompt = 'å½“å‰ TODO ä¿¡æ¯ï¼š\n' +
              '- æ ‡é¢˜: ' + issue.title + '\n' +
              '- å½“å‰çˆ¶ä»»åŠ¡: ' + (currentParent || 'æ— ') + '\n' +
              '- å½“å‰æˆªæ­¢æ—¥æœŸ: ' + (currentDue || 'æ— ') + '\n' +
              '- å½“å‰ä¼˜å…ˆçº§: ' + currentPriority + '\n' +
              '- å½“å‰ä»»åŠ¡ç±»å‹: ' + currentTaskType + '\n' +
              '- å½“å‰æ ‡ç­¾: ' + (currentLabels.join(', ') || 'æ— ') + '\n' +
              '- å½“å‰æ­£æ–‡: \n' + currentBody + '\n\n' +
              'ç”¨æˆ·çš„ä¿®æ”¹æŒ‡ä»¤ï¼š\n' + fixPrompt;

            let aiResponse;
            try {
              const postData = JSON.stringify({
                model: 'qwen-plus',
                messages: [
                  { role: 'system', content: fixSystemPrompt },
                  { role: 'user', content: fixUserPrompt }
                ],
                temperature: 0.3,
                response_format: { type: 'json_object' }
              });

              const options = {
                hostname: 'dashscope.aliyuncs.com',
                path: '/compatible-mode/v1/chat/completions',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': 'Bearer ' + process.env.DASHSCOPE_API_KEY,
                  'Content-Length': Buffer.byteLength(postData)
                }
              };

              aiResponse = await new Promise((resolve, reject) => {
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', (chunk) => { data += chunk; });
                  res.on('end', () => {
                    if (res.statusCode === 200) {
                      resolve(JSON.parse(data));
                    } else {
                      reject(new Error('API è¯·æ±‚å¤±è´¥: ' + res.statusCode + ' - ' + data));
                    }
                  });
                });

                req.on('error', (error) => reject(error));
                req.write(postData);
                req.end();
              });
            } catch (apiError) {
              core.error('è°ƒç”¨ AI ä¿®å¤æ¥å£å¤±è´¥ï¼š' + apiError.message);
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: 'âŒ AI æ›´æ–° TODO å¤±è´¥ï¼š' + apiError.message
              });
              return;
            }

            let parsedData;
            try {
              parsedData = JSON.parse(aiResponse.choices[0].message.content);
            } catch (parseError) {
              core.error('è§£æ AI ä¿®å¤ç»“æœå¤±è´¥ï¼š' + parseError.message);
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: 'âŒ AI è¿”å›ç»“æœè§£æå¤±è´¥ï¼š' + parseError.message
              });
              return;
            }

            parsedData.title = parsedData.title || issue.title;
            parsedData.task_type = parsedData.task_type || currentTaskType;

            const issueBody = buildIssueBodyFromParsedData(parsedData, issueNumber);

            const taskTypeLabel = parsedData.task_type === 'deadline' ? 'task-with-deadline' : 'task-open';
            const priorityLabel = 'priority:' + (parsedData.priority || currentPriority || 'medium');
            const preservedLabels = currentLabels.filter(l => !SYSTEM_LABELS.includes(l) || l === 'subtask');
            const finalLabels = preservedLabels
              .filter(l => !l.startsWith('priority:') && l !== 'task-with-deadline' && l !== 'task-open')
              .concat([taskTypeLabel, priorityLabel]);

            if (parsedData.parent_issue) {
              if (!finalLabels.includes('subtask')) {
                finalLabels.push('subtask');
              }
            } else {
              const idx = finalLabels.indexOf('subtask');
              if (idx >= 0) finalLabels.splice(idx, 1);
            }

            let milestoneNumber = null;
            if (parsedData.due_date && parsedData.task_type === 'deadline') {
              try {
                const milestoneTitle = parsedData.due_date + ' Deadline';
                const { data: existingMilestones } = await github.rest.issues.listMilestones({
                  owner,
                  repo,
                  state: 'open'
                });

                const existingMilestone = existingMilestones.find(m => m.title === milestoneTitle);

                if (existingMilestone) {
                  milestoneNumber = existingMilestone.number;
                } else {
                  const { data: newMilestone } = await github.rest.issues.createMilestone({
                    owner,
                    repo,
                    title: milestoneTitle,
                    due_on: parsedData.due_date + 'T23:59:59Z'
                  });
                  milestoneNumber = newMilestone.number;
                }
              } catch (milestoneError) {
                core.warning('åˆ›å»º/æŸ¥æ‰¾ milestone æ—¶å‡ºé”™ï¼š' + milestoneError.message);
              }
            }

            await github.rest.issues.update({
              owner,
              repo,
              issue_number: issueNumber,
              title: parsedData.title,
              body: issueBody,
              labels: finalLabels,
              milestone: parsedData.task_type === 'deadline' ? milestoneNumber : null
            });

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body: 'âœ… AI å·²æ ¹æ® /fix æ›´æ–° TODOã€‚\n\n- æ ‡é¢˜: ' + parsedData.title + '\n- æˆªæ­¢æ—¥æœŸ: ' + (parsedData.due_date || 'æ— ') + '\n- çˆ¶ä»»åŠ¡: ' + (parsedData.parent_issue ? ('#' + parsedData.parent_issue) : 'æ— ')
            });
