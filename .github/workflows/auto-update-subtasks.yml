name: Auto Link Subtasks

on:
  issues:
    types: [opened]

jobs:
  update-parent-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Auto add issue to parent project's subtask list
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueBody = context.payload.issue.body;
            const issueTitle = context.payload.issue.title;
            const issueNumber = context.payload.issue.number;
            const issueLabels = context.payload.issue.labels.map(l => l.name);
            const repo = context.repo.repo;
            const owner = context.repo.owner;
            
            // åŒ¹é…"åŸå§‹è¾“å…¥æ¥è‡ª: #æ•°å­—"æˆ–"å±äº#æ•°å­—"æˆ–"é¡¹ç›®#æ•°å­—"
            const parentMatch = issueBody.match(/åŸå§‹è¾“å…¥æ¥è‡ª[:ï¼š]?\s*#(\d+)|å±äº#?(\d+)/i);
            const parentNumber = parentMatch ? (parentMatch[1] || parentMatch[2]) : null;
            if (!parentNumber) {
              console.log("No parent issue referenced in body, skipping.");
              return;
            }
            
            // è·å–çˆ¶issuebody
            const parent = await github.rest.issues.get({
              owner, repo, issue_number: parentNumber,
            });
            let body = parent.data.body;
            
            // Inherit project tags from parent task
            try {
              // Load system labels from tags config
              const systemLabels = [
                'project', 'epic', 'task-with-deadline', 'task-open', 'subtask', 'ai-todo-inbox',
                'priority:critical', 'priority:high', 'priority:medium', 'priority:low',
                'status:planning', 'status:in-progress', 'status:blocked', 'status:review', 'status:testing',
                'type:feature', 'type:enhancement', 'type:bug', 'type:refactoring', 'type:documentation', 'type:research',
                'help-wanted', 'good-first-issue', 'duplicate', 'wontfix', 'archived'
              ];
              
              // Extract project labels from parent issue body
              const parentBody = parent.data.body || '';
              const projectLabelsMatch = parentBody.match(/\*\*é¡¹ç›®æ ‡ç­¾\*\*:\s*(?:<!--[\s\S]*?-->\s*)*([^\n<]+)/);
              
              let projectLabels = [];
              if (projectLabelsMatch && projectLabelsMatch[1]) {
                const labelText = projectLabelsMatch[1].trim();
                if (labelText && labelText !== '' && labelText !== '-' && labelText !== 'N/A') {
                  projectLabels = labelText.split(/[,ï¼Œ\s]+/)
                    .map(l => l.trim())
                    .filter(l => l && l !== '' && l !== '-');
                  console.log('ä»çˆ¶ä»»åŠ¡Bodyä¸­æå–åˆ°é¡¹ç›®æ ‡ç­¾: ' + projectLabels.join(', '));
                }
              }
              
              // Also inherit custom labels from parent if it's a project
              const parentLabels = parent.data.labels || [];
              const isProject = parentLabels.some(label => 
                typeof label === 'string' ? label === 'project' : label.name === 'project'
              );
              
              if (isProject) {
                parentLabels.forEach(label => {
                  const labelName = typeof label === 'string' ? label : label.name;
                  if (!systemLabels.includes(labelName) && !projectLabels.includes(labelName)) {
                    projectLabels.push(labelName);
                    console.log('ä»çˆ¶ä»»åŠ¡æ ‡ç­¾ç»§æ‰¿: ' + labelName);
                  }
                });
              }
              
              // Add project labels to the subtask
              if (projectLabels.length > 0) {
                const currentLabels = issueLabels;
                const labelsToAdd = projectLabels.filter(l => !currentLabels.includes(l));
                
                if (labelsToAdd.length > 0) {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    labels: labelsToAdd
                  });
                  console.log('æˆåŠŸä¸ºå­ä»»åŠ¡æ·»åŠ é¡¹ç›®æ ‡ç­¾: ' + labelsToAdd.join(', '));
                }
              }
            } catch (error) {
              console.log('ç»§æ‰¿é¡¹ç›®æ ‡ç­¾æ—¶å‡ºé”™ï¼š' + error.message);
              // Continue execution even if tag inheritance fails
            }
            
            // é˜²æ­¢é‡å¤ - æ£€æŸ¥çˆ¶ä»»åŠ¡çš„å­ä»»åŠ¡åˆ—è¡¨ä¸­æ˜¯å¦å·²åŒ…å«æ­¤issue
            // ä½¿ç”¨æ›´ç²¾ç¡®çš„æ¨¡å¼åŒ¹é…ï¼Œé¿å…è¯¯åˆ¤
            // issueNumber æ˜¯æ•´æ•°ï¼Œä½†ä¸ºäº†å®‰å…¨èµ·è§ï¼Œè½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶è½¬ä¹‰
            const escapedIssueNum = String(issueNumber).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const subtaskPattern = new RegExp(`^\\s*-\\s*\\[[ x]\\]\\s*#${escapedIssueNum}\\b`, 'm');
            if (subtaskPattern.test(body)) {
              console.log(`Issue #${issueNumber} already exists in parent issue #${parentNumber}'s subtask list, skipping to avoid duplication.`);
              return;
            }
            
            const lines = body.split('\n');
            // æ‰¾åˆ°"## ğŸ“ å­ä»»åŠ¡åˆ—è¡¨"ï¼Œæ’å…¥
            let found = false;
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].includes("## ğŸ“ å­ä»»åŠ¡åˆ—è¡¨")) {
                let insertIdx = i+1;
                // è·³è¿‡æ³¨é‡Šè¡Œ
                while (insertIdx < lines.length && lines[insertIdx].trim().startsWith('<')) insertIdx++;
                // æ·»åŠ å­ä»»åŠ¡é¡¹
                lines.splice(insertIdx, 0, `- [ ] #${issueNumber} - ${issueTitle}`);
                found = true;
                break;
              }
            }
            if (!found) {
              lines.push("\n## ğŸ“ å­ä»»åŠ¡åˆ—è¡¨");
              lines.push(`- [ ] #${issueNumber} - ${issueTitle}`);
            }
            await github.rest.issues.update({
              owner,
              repo,
              issue_number: parentNumber,
              body: lines.join('\n'),
            });
