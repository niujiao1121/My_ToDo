name: AI è‡ªåŠ¨åˆ›å»º TODO

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: read

jobs:
  ai-create-todo:
    runs-on: ubuntu-latest

    concurrency:
      group: ai-create-todo-${{ github.event.issue.number }}
      cancel-in-progress: true
    
    # åªåœ¨ä»¥ä¸‹æƒ…å†µè¿è¡Œï¼š
    # 1. Issue åœ¨è¢«æ‰“ä¸Š ai-todo-inbox æ ‡ç­¾æ—¶è§¦å‘
    # 2. è¯„è®ºä»¥ /todo æˆ– /fix å¼€å¤´
    if: |
      (github.event_name == 'issues' && github.event.action == 'labeled' && github.event.label.name == 'ai-todo-inbox') ||
      (github.event_name == 'issue_comment' && (contains(github.event.comment.body, '/todo') || contains(github.event.comment.body, '/fix')))
    
    steps:
      - name: æ£€æŸ¥æƒé™
        id: check-permission
        uses: actions/github-script@v7
        with:
          script: |
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ˜¯ä»“åº“æˆå‘˜æˆ–åä½œè€…
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: context.actor
              });
              
              const hasPermission = ['admin', 'write', 'maintain'].includes(permission.permission);
              
              if (!hasPermission) {
                const issueNumber = context.payload.issue.number;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: 'âŒ æŠ±æ­‰ï¼Œåªæœ‰ä»“åº“æˆå‘˜å¯ä»¥ä½¿ç”¨ AI TODO åˆ›å»ºåŠŸèƒ½ã€‚'
                });
                core.setFailed('ç”¨æˆ·æ²¡æœ‰è¶³å¤Ÿçš„æƒé™');
              }
              
              return hasPermission;
            } catch (error) {
              core.error('æ£€æŸ¥æƒé™æ—¶å‡ºé”™ï¼š' + error.message);
              return false;
            }

      - name: AI è§£æå¹¶åˆ›å»º TODO
        if: steps.check-permission.outputs.result == 'true'
        uses: actions/github-script@v7
        env:
          DASHSCOPE_API_KEY: ${{ secrets.DASHSCOPE_API_KEY }}
        with:
          script: |
            const https = require('https');

            const SYSTEM_LABELS = [
              'project', 'epic', 'task-with-deadline', 'task-open', 'subtask', 'ai-todo-inbox',
              'priority:critical', 'priority:high', 'priority:medium', 'priority:low',
              'status:planning', 'status:in-progress', 'status:blocked', 'status:review', 'status:testing',
              'type:feature', 'type:enhancement', 'type:bug', 'type:refactoring', 'type:documentation', 'type:research',
              'help-wanted', 'good-first-issue', 'duplicate', 'wontfix', 'archived'
            ];

            const buildIssueBodyFromParsedData = (parsedData, sourceIssueNumber) => {
              const parentIssueSection = parsedData.parent_issue
                ? '\n\n## ğŸ”— çˆ¶ä»»åŠ¡\n\n**Parent Issue**: #' + parsedData.parent_issue
                : '';

              if (parsedData.task_type === 'deadline') {
                const acceptanceCriteria = parsedData.acceptance_criteria && parsedData.acceptance_criteria.length > 0
                  ? parsedData.acceptance_criteria.map(c => '- [ ] ' + c).join('\n')
                  : '- [ ] å¾…è¡¥å……';
                const taskChecklist = parsedData.task_checklist && parsedData.task_checklist.length > 0
                  ? parsedData.task_checklist.map(t => '- [ ] ' + t).join('\n')
                  : '- [ ] å¾…è¡¥å……';

                return '## ğŸ“‹ ä»»åŠ¡æè¿°\n\n' + parsedData.description + parentIssueSection + '\n\n' +
                  '## â° æ—¶é—´è¦æ±‚\n\n' +
                  '**æˆªæ­¢æ—¥æœŸ**: ' + (parsedData.due_date || 'å¾…å®š') + ' â°\n' +
                  '**é¢„è®¡å·¥ä½œé‡**: ' + (parsedData.estimated_hours || 'å¾…è¯„ä¼°') + 'å°æ—¶\n\n' +
                  '## âœ… éªŒæ”¶æ ‡å‡†\n\n' + acceptanceCriteria + '\n\n' +
                  '## ğŸ“ ä»»åŠ¡æ¸…å•\n\n' + taskChecklist + '\n\n' +
                  '---\n\n' +
                  '*æ­¤ TODO ç”±é˜¿é‡Œäº‘ AI åŠ©æ‰‹ç”Ÿæˆ/æ›´æ–°*\n' +
                  '*åŸå§‹è¾“å…¥æ¥è‡ª: #' + sourceIssueNumber + '*';
              }

              const acceptanceCriteria = parsedData.acceptance_criteria && parsedData.acceptance_criteria.length > 0
                ? parsedData.acceptance_criteria.map(c => '- [ ] ' + c).join('\n')
                : '- [ ] å¾…è¡¥å……';
              const taskChecklist = parsedData.task_checklist && parsedData.task_checklist.length > 0
                ? parsedData.task_checklist.map((t, i) => (i + 1) + '. ' + t).join('\n')
                : 'å¾…è¡¥å……';

              return '## ğŸ“‹ ä»»åŠ¡æè¿°\n\n' + parsedData.description + parentIssueSection + '\n\n' +
                '## ğŸ¯ å®Œæˆæ¡ä»¶\n\n' +
                '**é¢„è®¡å·¥ä½œé‡**: ' + (parsedData.estimated_hours || 'å¾…è¯„ä¼°') + 'å°æ—¶\n\n' +
                '**éªŒæ”¶æ ‡å‡†**: \n' + acceptanceCriteria + '\n\n' +
                '## ğŸ“ å®ç°æ€è·¯\n\n' + taskChecklist + '\n\n' +
                '---\n\n' +
                '*æ­¤ TODO ç”±é˜¿é‡Œäº‘ AI åŠ©æ‰‹ç”Ÿæˆ/æ›´æ–°*\n' +
                '*åŸå§‹è¾“å…¥æ¥è‡ª: #' + sourceIssueNumber + '*';
            };

            const handleFixCommand = async (fixPrompt) => {
              const issue = context.payload.issue;
              const issueNumber = issue.number;
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              const currentLabels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
              const currentPriorityLabel = currentLabels.find(l => l.startsWith('priority:'));
              const currentPriority = currentPriorityLabel ? currentPriorityLabel.split(':')[1] : 'medium';
              const currentTaskType = currentLabels.includes('task-with-deadline') ? 'deadline' : 'open';
              const currentBody = issue.body || '';
              const currentDueMatch = currentBody.match(/æˆªæ­¢æ—¥æœŸ\*\*:\s*([0-9]{4}-[0-9]{2}-[0-9]{2}|å¾…å®š)/);
              const currentDue = currentDueMatch && currentDueMatch[1] !== 'å¾…å®š' ? currentDueMatch[1] : null;
              const parentMatch = currentBody.match(/Parent Issue\*\*:\s*#(\d+)/i) || currentBody.match(/åŸå§‹è¾“å…¥æ¥è‡ª[:ï¼š]?\s*#(\d+)/i) || currentBody.match(/å±äº#?(\d+)/i);
              const currentParent = parentMatch ? parentMatch[1] : null;

              const fixSystemPrompt = 'ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ TODO ç»´æŠ¤åŠ©æ‰‹ã€‚æ ¹æ®ç”¨æˆ·æä¾›çš„ä¿®æ”¹æŒ‡ä»¤å’Œå½“å‰ TODO å†…å®¹ï¼Œè¿”å›æ›´æ–°åçš„ç»“æ„åŒ–æ•°æ®ã€‚' +
                'å¦‚æœç”¨æˆ·æ²¡æœ‰æ˜ç¡®ä¿®æ”¹æŸä¸ªå­—æ®µï¼Œè¯·ä¿ç•™å½“å‰å€¼ã€‚ç¡®ä¿è¾“å‡ºå­—æ®µéµå¾ªä»¥ä¸‹æ ¼å¼ï¼š\n' +
                '{\n' +
                '  "title": "æ›´æ–°åçš„æ ‡é¢˜",\n' +
                '  "description": "æ›´æ–°åçš„ä»»åŠ¡æè¿°ï¼Œä¿ç•™å…³é”®èƒŒæ™¯ä¿¡æ¯",\n' +
                '  "parent_issue": "çˆ¶ä»»åŠ¡ç¼–å·æˆ– null",\n' +
                '  "due_date": "YYYY-MM-DD æˆ– null",\n' +
                '  "priority": "critical/high/medium/low",\n' +
                '  "estimated_hours": "é¢„è®¡å·¥æ—¶ï¼Œä¿ç•™æˆ–æŒ‰éœ€æ±‚è°ƒæ•´",\n' +
                '  "acceptance_criteria": ["éªŒæ”¶æ ‡å‡†1", "éªŒæ”¶æ ‡å‡†2"],\n' +
                '  "task_checklist": ["æ­¥éª¤1", "æ­¥éª¤2"],\n' +
                '  "task_type": "deadline æˆ– openï¼ŒåŸºäºæ˜¯å¦æœ‰æˆªæ­¢æ—¥æœŸ"\n' +
                '}\n' +
                'éœ€è¦ç¡®ä¿æˆªæ­¢æ—¶é—´ã€çˆ¶å­ä»»åŠ¡å…³ç³»ç­‰ä¿¡æ¯æ ¼å¼ç¬¦åˆå½“å‰ä»“åº“çš„æƒ¯ä¾‹ã€‚åªè¿”å› JSONï¼Œä¸è¦åŒ…å«å…¶ä»–æ–‡å­—ã€‚';

              const fixUserPrompt = 'å½“å‰ TODO ä¿¡æ¯ï¼š\n' +
                '- æ ‡é¢˜: ' + issue.title + '\n' +
                '- å½“å‰çˆ¶ä»»åŠ¡: ' + (currentParent || 'æ— ') + '\n' +
                '- å½“å‰æˆªæ­¢æ—¥æœŸ: ' + (currentDue || 'æ— ') + '\n' +
                '- å½“å‰ä¼˜å…ˆçº§: ' + currentPriority + '\n' +
                '- å½“å‰ä»»åŠ¡ç±»å‹: ' + currentTaskType + '\n' +
                '- å½“å‰æ ‡ç­¾: ' + (currentLabels.join(', ') || 'æ— ') + '\n' +
                '- å½“å‰æ­£æ–‡: \n' + currentBody + '\n\n' +
                'ç”¨æˆ·çš„ä¿®æ”¹æŒ‡ä»¤ï¼š\n' + fixPrompt;

              let aiResponse;
              try {
                const postData = JSON.stringify({
                  model: 'qwen-plus',
                  messages: [
                    { role: 'system', content: fixSystemPrompt },
                    { role: 'user', content: fixUserPrompt }
                  ],
                  temperature: 0.3,
                  response_format: { type: 'json_object' }
                });

                const options = {
                  hostname: 'dashscope.aliyuncs.com',
                  path: '/compatible-mode/v1/chat/completions',
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + process.env.DASHSCOPE_API_KEY,
                    'Content-Length': Buffer.byteLength(postData)
                  }
                };

                aiResponse = await new Promise((resolve, reject) => {
                  const req = https.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => { data += chunk; });
                    res.on('end', () => {
                      if (res.statusCode === 200) {
                        resolve(JSON.parse(data));
                      } else {
                        reject(new Error('API è¯·æ±‚å¤±è´¥: ' + res.statusCode + ' - ' + data));
                      }
                    });
                  });

                  req.on('error', (error) => reject(error));
                  req.write(postData);
                  req.end();
                });
              } catch (apiError) {
                core.error('è°ƒç”¨ AI ä¿®å¤æ¥å£å¤±è´¥ï¼š' + apiError.message);
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body: 'âŒ AI æ›´æ–° TODO å¤±è´¥ï¼š' + apiError.message
                });
                return;
              }

              let parsedData;
              try {
                parsedData = JSON.parse(aiResponse.choices[0].message.content);
              } catch (parseError) {
                core.error('è§£æ AI ä¿®å¤ç»“æœå¤±è´¥ï¼š' + parseError.message);
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body: 'âŒ AI è¿”å›ç»“æœè§£æå¤±è´¥ï¼š' + parseError.message
                });
                return;
              }

              parsedData.title = parsedData.title || issue.title;
              parsedData.task_type = parsedData.task_type || currentTaskType;

              const issueBody = buildIssueBodyFromParsedData(parsedData, issueNumber);

              const taskTypeLabel = parsedData.task_type === 'deadline' ? 'task-with-deadline' : 'task-open';
              const priorityLabel = 'priority:' + (parsedData.priority || currentPriority || 'medium');
              const preservedLabels = currentLabels.filter(l => !SYSTEM_LABELS.includes(l) || l === 'subtask');
              const finalLabels = preservedLabels
                .filter(l => !l.startsWith('priority:') && l !== 'task-with-deadline' && l !== 'task-open')
                .concat([taskTypeLabel, priorityLabel]);

              if (parsedData.parent_issue) {
                if (!finalLabels.includes('subtask')) {
                  finalLabels.push('subtask');
                }
              } else {
                const idx = finalLabels.indexOf('subtask');
                if (idx >= 0) finalLabels.splice(idx, 1);
              }

              let milestoneNumber = null;
              if (parsedData.due_date && parsedData.task_type === 'deadline') {
                try {
                  const milestoneTitle = parsedData.due_date + ' Deadline';
                  const { data: existingMilestones } = await github.rest.issues.listMilestones({
                    owner,
                    repo,
                    state: 'open'
                  });

                  const existingMilestone = existingMilestones.find(m => m.title === milestoneTitle);

                  if (existingMilestone) {
                    milestoneNumber = existingMilestone.number;
                  } else {
                    const { data: newMilestone } = await github.rest.issues.createMilestone({
                      owner,
                      repo,
                      title: milestoneTitle,
                      due_on: parsedData.due_date + 'T23:59:59Z'
                    });
                    milestoneNumber = newMilestone.number;
                  }
                } catch (milestoneError) {
                  core.warning('åˆ›å»º/æŸ¥æ‰¾ milestone æ—¶å‡ºé”™ï¼š' + milestoneError.message);
                }
              }

              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                title: parsedData.title,
                body: issueBody,
                labels: finalLabels,
                milestone: parsedData.task_type === 'deadline' ? milestoneNumber : null
              });

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: 'âœ… AI å·²æ ¹æ®æç¤ºæ›´æ–° TODOã€‚\n\n- æ ‡é¢˜: ' + parsedData.title + '\n- æˆªæ­¢æ—¥æœŸ: ' + (parsedData.due_date || 'æ— ') + '\n- çˆ¶ä»»åŠ¡: ' + (parsedData.parent_issue ? ('#' + parsedData.parent_issue) : 'æ— ')
              });
            };
            
            // è·å–ç”¨æˆ·è¾“å…¥
            let userInputs = []; // æ”¹ä¸ºæ•°ç»„ä»¥æ”¯æŒæ‰¹é‡åˆ›å»º
            let sourceIssueNumber = null;
            let autoParentIssue = null; // è‡ªåŠ¨æ£€æµ‹çš„çˆ¶ä»»åŠ¡
            
            if (context.eventName === 'issues') {
              let userInput = context.payload.issue.body || '';
              sourceIssueNumber = context.payload.issue.number;
              // æ¸…ç†æ¨¡æ¿ä¸­çš„æ³¨é‡Š
              userInput = userInput.replace(/<!--[\s\S]*?-->/g, '').trim();
              // æå–"æˆ‘è¦åšçš„äº‹"éƒ¨åˆ†çš„å†…å®¹
              // æ­£åˆ™è¯´æ˜ï¼šåŒ¹é… ## æˆ‘è¦åšçš„äº‹ åé¢çš„å†…å®¹ï¼Œç›´åˆ°é‡åˆ°ä¸‹ä¸€ä¸ª ## æˆ– --- æˆ–æ–‡ä»¶ç»“å°¾
              const contentMatch = userInput.match(/##\s*æˆ‘è¦åšçš„äº‹\s*\n+([\s\S]+?)(?=\n##|\n---|$)/i);
              if (contentMatch) {
                userInput = contentMatch[1].trim();
              }
              userInputs.push(userInput);
            } else if (context.eventName === 'issue_comment') {
              const comment = (context.payload.comment.body || '').trim();
              sourceIssueNumber = context.payload.issue.number;
              // å½“ä»è¯„è®ºåˆ›å»ºæ—¶ï¼Œè‡ªåŠ¨è®¾ç½®çˆ¶ä»»åŠ¡ä¸ºè¢«è¯„è®ºçš„issue
              autoParentIssue = sourceIssueNumber;

              const fixMatch = comment.match(/^\/fix\s+([\s\S]+)/im);
              if (fixMatch) {
                const fixPrompt = fixMatch[1].trim();
                if (!fixPrompt) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: sourceIssueNumber,
                    body: 'âŒ /fix æŒ‡ä»¤åéœ€è¦æä¾›ä¿®æ”¹è¯´æ˜ã€‚'
                  });
                  return;
                }

                await handleFixCommand(fixPrompt);
                return;
              }

              // æ£€æµ‹å¤šä¸ª /todo å‘½ä»¤ï¼ˆæ”¯æŒæ‰¹é‡åˆ›å»ºï¼‰
              const todoPattern = /^\/todo\s+(.+)$/gmi;
              const matches = [...comment.matchAll(todoPattern)];
              
              if (matches.length > 0) {
                // æ‰¾åˆ°å¤šä¸ª /todo å‘½ä»¤
                userInputs = matches.map(match => match[1].trim());
                core.info('æ£€æµ‹åˆ° ' + matches.length + ' ä¸ª /todo å‘½ä»¤');
              } else {
                // å…¼å®¹æ—§æ ¼å¼ï¼šæ•´ä¸ªè¯„è®ºä»¥ /todo å¼€å¤´
                const singleTodo = comment.replace(/^\/todo\s+/i, '').trim();
                if (singleTodo) {
                  userInputs.push(singleTodo);
                }
              }
            }
            
            if (userInputs.length === 0 || !userInputs[0]) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'âŒ è¯·æä¾›è¦åˆ›å»ºçš„ TODO å†…å®¹ã€‚'
              });
              return;
            }

            // é¿å…é‡å¤åˆ›å»ºï¼š
            // - å¯¹ issue_comment è§¦å‘ï¼Œåªæœ‰å½“æœ€æ–°çš„ /todo è¯„è®ºä¹‹åå·²ç»æœ‰æœºå™¨äººç”Ÿæˆçš„ç»“æœæ—¶æ‰è·³è¿‡
            // - å¯¹ issues è§¦å‘ï¼Œä¿æŒåŸæœ‰çš„é˜²é‡å¤é€»è¾‘
            try {
              const { data: existingComments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                per_page: 50
              });

              const processedMarkers = ['AI å·²æˆåŠŸåˆ›å»º TODO', 'æ‰¹é‡ TODO åˆ›å»ºå®Œæˆ'];
              const isMarkerComment = (comment) =>
                processedMarkers.some(marker => comment.body && comment.body.includes(marker)) &&
                comment.user && comment.user.login === 'github-actions[bot]';

              let alreadyProcessed = false;

              if (context.eventName === 'issue_comment') {
                const currentCreatedAt = new Date(context.payload.comment.created_at);

                // æ‰¾åˆ°å½“å‰è¯„è®ºä¹‹å‰ï¼ˆå«å½“å‰ï¼‰çš„æœ€æ–° /todo è¯„è®ºæ—¶é—´
                const latestTodoComment = existingComments
                  .filter(c => {
                    const hasTodo = (c.body || '').toLowerCase().includes('/todo');
                    return hasTodo && new Date(c.created_at) <= currentCreatedAt;
                  })
                  .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];

                if (latestTodoComment) {
                  const latestTodoTime = new Date(latestTodoComment.created_at);

                  // åªæœ‰å½“æœ€æ–°çš„ /todo è¯„è®ºä¹‹åå·²ç»æœ‰æœºå™¨äººå›å¤äº†æˆåŠŸ/æ‰¹é‡å®Œæˆæç¤ºæ‰è®¤ä¸ºå·²å¤„ç†
                  alreadyProcessed = existingComments.some(comment =>
                    isMarkerComment(comment) && new Date(comment.created_at) >= latestTodoTime
                  );
                }
              } else {
                alreadyProcessed = existingComments.some(comment => isMarkerComment(comment));
              }

              if (alreadyProcessed) {
                core.info('æ£€æµ‹åˆ°å½“å‰ Issue å·²æœ‰ AI åˆ›å»º TODO çš„ç»“æœï¼Œè·³è¿‡é‡å¤å¤„ç†');
                return;
              }
            } catch (commentError) {
              core.warning('æ£€æŸ¥æ˜¯å¦å·²å¤„ç†æ—¶å‡ºé”™ï¼š' + commentError.message + 'ï¼Œå°†ç»§ç»­å°è¯•åˆ›å»º');
            }

            // æ£€æŸ¥é˜¿é‡Œäº‘ API Key
            if (!process.env.DASHSCOPE_API_KEY) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'âŒ é˜¿é‡Œäº‘ API Key æœªé…ç½®ã€‚è¯·åœ¨ä»“åº“çš„ Secrets ä¸­æ·»åŠ  `DASHSCOPE_API_KEY`ã€‚\n\né…ç½®æ­¥éª¤ï¼šhttps://github.com/' + context.repo.owner + '/' + context.repo.repo + '/blob/main/docs/AI_SETUP.md'
              });
              return;
            }
            
            // æ‰¹é‡åˆ›å»º TODO - ä¸ºæ¯ä¸ªè¾“å…¥åˆ›å»ºä¸€ä¸ª Issue
            const createdIssues = [];
            const batchCount = userInputs.length;
            
            // å¦‚æœæ˜¯æ‰¹é‡åˆ›å»ºï¼Œå…ˆå‘é€æç¤ºæ¶ˆæ¯
            if (batchCount > 1) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'ğŸ”„ æ£€æµ‹åˆ° ' + batchCount + ' ä¸ª TODOï¼Œæ­£åœ¨æ‰¹é‡åˆ›å»º...'
              });
            }
            
            // æ„å»º AI æç¤ºè¯ï¼ˆåœ¨å¾ªç¯å¤–å®šä¹‰ï¼Œé‡å¤ä½¿ç”¨ï¼‰
            // Note: ä½¿ç”¨å­—ç¬¦ä¸²æ‹¼æ¥è€Œéæ¨¡æ¿å­—é¢é‡ä»¥é¿å… YAML è§£æé—®é¢˜
            const currentDate = new Date().toISOString().split('T')[0];
            const systemPrompt = 'ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä»»åŠ¡ç®¡ç†åŠ©æ‰‹ã€‚ç”¨æˆ·ä¼šç”¨ä¸­æ–‡æˆ–è‹±æ–‡æè¿°ä¸€ä¸ªä»»åŠ¡ï¼Œä½ éœ€è¦å°†å…¶è§£æä¸ºç»“æ„åŒ–çš„ TODOã€‚\n\n' +
              'å½“å‰æ—¥æœŸ: ' + currentDate + '\n\n' +
              'è¯·åˆ†æç”¨æˆ·è¾“å…¥ï¼Œæå–ä»¥ä¸‹ä¿¡æ¯å¹¶ä»¥ JSON æ ¼å¼è¿”å›ï¼š\n\n' +
              '{\n' +
              '  "title": "ç®€æ´æ˜äº†çš„ä»»åŠ¡æ ‡é¢˜ï¼ˆ10-50å­—ï¼‰",\n' +
              '  "description": "è¯¦ç»†çš„ä»»åŠ¡æè¿°ï¼ŒåŒ…å«èƒŒæ™¯å’Œå…·ä½“è¦åšçš„äº‹æƒ…",\n' +
              '  "parent_issue": "çˆ¶ä»»åŠ¡ç¼–å·ï¼Œå¦‚æœç”¨æˆ·æåˆ° #æ•°å­—ã€parent #æ•°å­—ã€å±äº#æ•°å­—ã€ä»å±äº#æ•°å­—ã€å­ä»»åŠ¡ã€subtask of ç­‰ï¼Œæå–æ•°å­—ï¼Œå¦åˆ™ä¸º null",\n' +
              '  "due_date": "æˆªæ­¢æ—¥æœŸ YYYY-MM-DD æ ¼å¼ï¼Œå¦‚æœç”¨æˆ·æåˆ°äº†æ—¥æœŸç›¸å…³çš„è¯ï¼ˆä»Šå¤©ã€æ˜å¤©ã€ä¸‹å‘¨ç­‰ï¼‰åˆ™è®¡ç®—å…·ä½“æ—¥æœŸï¼Œå¦åˆ™ä¸º null",\n' +
              '  "priority": "ä¼˜å…ˆçº§: critical/high/medium/lowï¼Œæ ¹æ®ç”¨æˆ·ç”¨è¯åˆ¤æ–­ï¼ˆç´§æ€¥ã€é‡è¦ç­‰ï¼‰ï¼Œé»˜è®¤ medium",\n' +
              '  "estimated_hours": "é¢„è®¡å·¥ä½œé‡ï¼ˆå°æ—¶æ•°ï¼‰ï¼Œå¦‚æœç”¨æˆ·æåˆ°äº†å·¥ä½œé‡åˆ™æå–ï¼Œå¦åˆ™æ ¹æ®ä»»åŠ¡å¤æ‚åº¦ä¼°ç®—ï¼Œæ ¼å¼å¦‚ \'8\' æˆ– \'16-24\'",\n' +
              '  "acceptance_criteria": ["éªŒæ”¶æ ‡å‡†1", "éªŒæ”¶æ ‡å‡†2"],\n' +
              '  "task_checklist": ["æ­¥éª¤1", "æ­¥éª¤2"],\n' +
              '  "task_type": "ä»»åŠ¡ç±»å‹: deadline æˆ– openï¼Œå¦‚æœæœ‰æˆªæ­¢æ—¥æœŸç”¨ deadlineï¼Œå¦åˆ™ç”¨ open"\n' +
              '}\n\n' +
              'çˆ¶ä»»åŠ¡è¯†åˆ«è§„åˆ™ï¼š\n' +
              '- "#æ•°å­—" æ ¼å¼ï¼ˆå¦‚ "#123"ï¼‰-> æå–æ•°å­— 123\n' +
              '- "parent #æ•°å­—"ã€"Parent: #æ•°å­—" -> æå–æ•°å­—\n' +
              '- "å±äº #æ•°å­—"ã€"ä»å±äº #æ•°å­—" -> æå–æ•°å­—\n' +
              '- "æ˜¯ #æ•°å­— çš„å­ä»»åŠ¡" -> æå–æ•°å­—\n' +
              '- "subtask of #æ•°å­—" -> æå–æ•°å­—\n' +
              '- å¦‚æœæ²¡æœ‰æåˆ°çˆ¶ä»»åŠ¡ -> null\n\n' +
              'æ—¥æœŸè¯†åˆ«è§„åˆ™ï¼š\n' +
              '- "ä»Šå¤©" -> ' + currentDate + '\n' +
              '- "æ˜å¤©" -> å½“å‰æ—¥æœŸ+1å¤©\n' +
              '- "åå¤©" -> å½“å‰æ—¥æœŸ+2å¤©\n' +
              '- "ä¸‹å‘¨" -> å½“å‰æ—¥æœŸ+7å¤©\n' +
              '- "ä¸‹å‘¨ä¸€/äºŒ/..." -> è®¡ç®—ä¸‹å‘¨å¯¹åº”çš„æ—¥æœŸ\n' +
              '- "ä¸‹æœˆ" -> å½“å‰æ—¥æœŸ+30å¤©\n' +
              '- "æœˆåº•" -> å½“æœˆæœ€åä¸€å¤©\n' +
              '- å…·ä½“æ—¥æœŸå¦‚ "12æœˆ25æ—¥" -> è½¬æ¢ä¸º YYYY-MM-DD\n\n' +
              'ä¼˜å…ˆçº§åˆ¤æ–­ï¼š\n' +
              '- åŒ…å«"ç´§æ€¥"ã€"urgent"ã€"ASAP"ã€"ç«‹å³" -> critical\n' +
              '- åŒ…å«"é‡è¦"ã€"high"ã€"å…³é”®" -> high\n' +
              '- åŒ…å«"ä¸€èˆ¬"ã€"normal"ã€"medium" -> medium\n' +
              '- åŒ…å«"ä¸æ€¥"ã€"low"ã€"å¯é€‰" -> low\n' +
              '- é»˜è®¤ -> medium\n\n' +
              'åªè¿”å› JSONï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—ã€‚';

            // å¾ªç¯å¤„ç†æ¯ä¸ª TODO è¾“å…¥
            for (let todoIndex = 0; todoIndex < userInputs.length; todoIndex++) {
              const userInput = userInputs[todoIndex];
              core.info('å¤„ç†ç¬¬ ' + (todoIndex + 1) + '/' + batchCount + ' ä¸ª TODO: ' + userInput);

            const userPrompt = 'ç”¨æˆ·è¾“å…¥ï¼š\n' + userInput;
            
            // è°ƒç”¨é˜¿é‡Œäº‘åƒé—® API
            let aiResponse;
            try {
              const postData = JSON.stringify({
                model: 'qwen-plus',
                messages: [
                  { role: 'system', content: systemPrompt },
                  { role: 'user', content: userPrompt }
                ],
                temperature: 0.3,
                response_format: { type: 'json_object' }
              });
              
              const options = {
                hostname: 'dashscope.aliyuncs.com',
                path: '/compatible-mode/v1/chat/completions',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': 'Bearer ' + process.env.DASHSCOPE_API_KEY,
                  'Content-Length': Buffer.byteLength(postData)
                }
              };
              
              aiResponse = await new Promise((resolve, reject) => {
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', (chunk) => { data += chunk; });
                  res.on('end', () => {
                    if (res.statusCode === 200) {
                      resolve(JSON.parse(data));
                    } else {
                      reject(new Error('API è¯·æ±‚å¤±è´¥: ' + res.statusCode + ' - ' + data));
                    }
                  });
                });
                
                req.on('error', (error) => reject(error));
                req.write(postData);
                req.end();
              });
              
              core.info('é˜¿é‡Œäº‘ API å“åº”ï¼š' + JSON.stringify(aiResponse));
              
            } catch (error) {
              core.error('è°ƒç”¨é˜¿é‡Œäº‘ API å¤±è´¥ï¼š' + error.message);
              
              // å¤±è´¥æ—¶ä½¿ç”¨åŸºæœ¬ä¿¡æ¯åˆ›å»º Issue
              try {
                const basicIssue = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: '[TODO] ' + userInput.substring(0, 50),
                  body: '## ğŸ“‹ ä»»åŠ¡æè¿°\n\n' + userInput + '\n\n---\n\n*æ­¤ TODO ç”± AI åŠ©æ‰‹è‡ªåŠ¨åˆ›å»ºï¼ˆAI è§£æå¤±è´¥ï¼Œä½¿ç”¨åŸºæœ¬æ ¼å¼ï¼‰*',
                  labels: ['task-open', 'priority:medium'],
                  assignees: [context.actor]
                });
                
                createdIssues.push({
                  number: basicIssue.data.number,
                  title: userInput.substring(0, 50),
                  url: basicIssue.data.html_url,
                  error: 'AI è§£æå¤±è´¥'
                });
              } catch (createError) {
                core.error('åˆ›å»ºåŸºæœ¬ Issue ä¹Ÿå¤±è´¥ï¼š' + createError.message);
                createdIssues.push({
                  error: 'åˆ›å»ºå¤±è´¥: ' + createError.message,
                  input: userInput
                });
              }
              
              // ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ª TODO
              continue;
            }
            
            // è§£æ AI å“åº”
            let parsedData;
            try {
              const content = aiResponse.choices[0].message.content;
              parsedData = JSON.parse(content);
              core.info('è§£æåçš„æ•°æ®ï¼š' + JSON.stringify(parsedData));
              
              // å¦‚æœä»è¯„è®ºåˆ›å»ºä¸”AIæ²¡æœ‰è¯†åˆ«å‡ºçˆ¶ä»»åŠ¡ï¼Œä½¿ç”¨è‡ªåŠ¨æ£€æµ‹çš„çˆ¶ä»»åŠ¡
              if (autoParentIssue && !parsedData.parent_issue) {
                parsedData.parent_issue = autoParentIssue.toString();
                core.info('è‡ªåŠ¨è®¾ç½®çˆ¶ä»»åŠ¡ä¸º: ' + autoParentIssue);
              }
            } catch (error) {
              core.error('è§£æ AI å“åº”å¤±è´¥ï¼š' + error.message);
              createdIssues.push({
                error: 'è§£æå¤±è´¥: ' + error.message,
                input: userInput
              });
              // ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ª TODO
              continue;
            }
            
            // æ„å»º Issue å†…å®¹
            const taskType = parsedData.task_type === 'deadline' ? 'task-with-deadline' : 'task-open';
            const titlePrefix = taskType === 'task-with-deadline' ? '[TASK]' : '[OPEN]';
            
            // æ·»åŠ çˆ¶ä»»åŠ¡æ ‡è®°ï¼ˆå¦‚æœæŒ‡å®šäº†çˆ¶ä»»åŠ¡ï¼‰
            const parentIssueSection = parsedData.parent_issue 
              ? '\n\n## ğŸ”— çˆ¶ä»»åŠ¡\n\n**Parent Issue**: #' + parsedData.parent_issue
              : '';
            
            let issueBody = '';
            
            if (taskType === 'task-with-deadline') {
              // æœ‰æˆªæ­¢æ—¥æœŸçš„ä»»åŠ¡æ¨¡æ¿
              const acceptanceCriteria = parsedData.acceptance_criteria && parsedData.acceptance_criteria.length > 0 
                ? parsedData.acceptance_criteria.map(c => '- [ ] ' + c).join('\n')
                : '- [ ] å¾…è¡¥å……';
              const taskChecklist = parsedData.task_checklist && parsedData.task_checklist.length > 0
                ? parsedData.task_checklist.map(t => '- [ ] ' + t).join('\n')
                : '- [ ] å¾…è¡¥å……';
              
              issueBody = '## ğŸ“‹ ä»»åŠ¡æè¿°\n\n' + parsedData.description + parentIssueSection + '\n\n' +
                '## â° æ—¶é—´è¦æ±‚\n\n' +
                '**æˆªæ­¢æ—¥æœŸ**: ' + (parsedData.due_date || 'å¾…å®š') + ' â°\n' +
                '**é¢„è®¡å·¥ä½œé‡**: ' + (parsedData.estimated_hours || 'å¾…è¯„ä¼°') + 'å°æ—¶\n\n' +
                '## âœ… éªŒæ”¶æ ‡å‡†\n\n' + acceptanceCriteria + '\n\n' +
                '## ğŸ“ ä»»åŠ¡æ¸…å•\n\n' + taskChecklist + '\n\n' +
                '---\n\n' +
                '*æ­¤ TODO ç”±é˜¿é‡Œäº‘ AI åŠ©æ‰‹æ ¹æ®è¾“å…¥è‡ªåŠ¨åˆ›å»º*\n' +
                '*åŸå§‹è¾“å…¥æ¥è‡ª: #' + sourceIssueNumber + '*';
            } else {
              // å¼€æ”¾æ€§ä»»åŠ¡æ¨¡æ¿
              const acceptanceCriteria = parsedData.acceptance_criteria && parsedData.acceptance_criteria.length > 0 
                ? parsedData.acceptance_criteria.map(c => '- [ ] ' + c).join('\n')
                : '- [ ] å¾…è¡¥å……';
              const taskChecklist = parsedData.task_checklist && parsedData.task_checklist.length > 0
                ? parsedData.task_checklist.map((t, i) => (i + 1) + '. ' + t).join('\n')
                : 'å¾…è¡¥å……';
              
              issueBody = '## ğŸ“‹ ä»»åŠ¡æè¿°\n\n' + parsedData.description + parentIssueSection + '\n\n' +
                '## ğŸ¯ å®Œæˆæ¡ä»¶\n\n' +
                '**é¢„è®¡å·¥ä½œé‡**: ' + (parsedData.estimated_hours || 'å¾…è¯„ä¼°') + 'å°æ—¶\n\n' +
                '**éªŒæ”¶æ ‡å‡†**: \n' + acceptanceCriteria + '\n\n' +
                '## ğŸ“ å®ç°æ€è·¯\n\n' + taskChecklist + '\n\n' +
                '---\n\n' +
                '*æ­¤ TODO ç”±é˜¿é‡Œäº‘ AI åŠ©æ‰‹æ ¹æ®è¾“å…¥è‡ªåŠ¨åˆ›å»º*\n' +
                '*åŸå§‹è¾“å…¥æ¥è‡ª: #' + sourceIssueNumber + '*';
            }
            
            // ç¡®å®šæ ‡ç­¾
            const labels = [taskType, 'priority:' + (parsedData.priority || 'medium')];
            // åªæœ‰ä»è¯„è®ºåˆ›å»ºçš„å­ä»»åŠ¡æ‰æ·»åŠ  subtask æ ‡ç­¾
            // ä» issue åˆ›å»ºæ—¶ï¼Œå³ä½¿æœ‰çˆ¶ä»»åŠ¡ä¹Ÿä¸æ·»åŠ ï¼Œå› ä¸ºåŸ issue ä¼šè¢«åˆ é™¤
            // context.eventName æ¥è‡ªworkflowè§¦å‘äº‹ä»¶ï¼š'issues' æˆ– 'issue_comment'
            if (parsedData.parent_issue && context.eventName === 'issue_comment') {
              labels.push('subtask');
            }
            
            // å¦‚æœæœ‰æˆªæ­¢æ—¥æœŸï¼Œåˆ›å»ºæˆ–æŸ¥æ‰¾å¯¹åº”çš„ Milestone
            let milestoneNumber = null;
            if (parsedData.due_date && taskType === 'task-with-deadline') {
              try {
                // ç”Ÿæˆ milestone æ ‡é¢˜ï¼ˆæ ¼å¼ï¼šYYYY-MM-DD Deadlineï¼‰
                const milestoneTitle = parsedData.due_date + ' Deadline';
                
                // æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨ç›¸åŒæ—¥æœŸçš„ milestone
                // æ³¨æ„ï¼šåªæŸ¥æ‰¾å‰ 30 ä¸ª open milestonesï¼ˆGitHub API é»˜è®¤é™åˆ¶ï¼‰
                // å¯¹äºå¤§å¤šæ•°ä»“åº“æ¥è¯´è¿™å·²ç»è¶³å¤Ÿ
                const { data: existingMilestones } = await github.rest.issues.listMilestones({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open'
                });
                
                const existingMilestone = existingMilestones.find(m => m.title === milestoneTitle);
                
                if (existingMilestone) {
                  milestoneNumber = existingMilestone.number;
                  core.info('ä½¿ç”¨ç°æœ‰ Milestone #' + milestoneNumber + ': ' + milestoneTitle);
                } else {
                  // åˆ›å»ºæ–°çš„ milestone
                  const { data: newMilestone } = await github.rest.issues.createMilestone({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: milestoneTitle,
                    due_on: parsedData.due_date + 'T23:59:59Z',
                    description: 'æˆªæ­¢æ—¥æœŸä¸º ' + parsedData.due_date + ' çš„ä»»åŠ¡é›†åˆ'
                  });
                  milestoneNumber = newMilestone.number;
                  core.info('åˆ›å»ºæ–° Milestone #' + milestoneNumber + ': ' + milestoneTitle);
                }
              } catch (error) {
                core.warning('åˆ›å»ºæˆ–æŸ¥æ‰¾ Milestone å¤±è´¥ï¼š' + error.message);
                // Milestone åˆ›å»ºå¤±è´¥ä¸å½±å“ Issue åˆ›å»ºï¼Œç»§ç»­æ‰§è¡Œ
              }
            }
            
            // åˆ›å»ºæ–° Issue
            try {
              const issueParams = {
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: titlePrefix + ' ' + parsedData.title,
                body: issueBody,
                labels: labels,
                assignees: [context.actor]
              };
              
              // å¦‚æœæœ‰ milestoneï¼Œæ·»åŠ åˆ° issue å‚æ•°ä¸­
              if (milestoneNumber) {
                issueParams.milestone = milestoneNumber;
              }
              
              const newIssue = await github.rest.issues.create(issueParams);
              
              // å¦‚æœæŒ‡å®šäº†çˆ¶ä»»åŠ¡ï¼Œå°è¯•æ›´æ–°çˆ¶ä»»åŠ¡å¹¶ç»§æ‰¿é¡¹ç›®æ ‡ç­¾
              if (parsedData.parent_issue) {
                try {
                  const parentIssue = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parseInt(parsedData.parent_issue)
                  });
                  
                  // æå–çˆ¶ä»»åŠ¡çš„é¡¹ç›®æ ‡ç­¾ï¼ˆä» issue body ä¸­æå–ï¼‰
                  const parentBody = parentIssue.data.body || '';
                  // åŒ¹é… **é¡¹ç›®æ ‡ç­¾**: åé¢çš„å†…å®¹ï¼Œè·³è¿‡æ‰€æœ‰HTMLæ³¨é‡Š
                  const projectLabelsMatch = parentBody.match(/\*\*é¡¹ç›®æ ‡ç­¾\*\*:\s*(?:<!--[\s\S]*?-->\s*)*([^\n<]+)/);
                  
                  let projectLabels = [];
                  if (projectLabelsMatch && projectLabelsMatch[1]) {
                    const labelText = projectLabelsMatch[1].trim();
                    if (labelText && labelText !== '' && labelText !== '-' && labelText !== 'N/A') {
                      // è§£ææ ‡ç­¾ï¼Œæ”¯æŒé€—å·ã€ç©ºæ ¼ã€ä¸­æ–‡é€—å·åˆ†éš”
                      projectLabels = labelText.split(/[,ï¼Œ\s]+/)
                        .map(l => l.trim())
                        .filter(l => l && l !== '' && l !== '-');
                      core.info('ä»çˆ¶ä»»åŠ¡æå–åˆ°é¡¹ç›®æ ‡ç­¾: ' + projectLabels.join(', '));
                    }
                  }
                  
                  // å¦‚æœçˆ¶ä»»åŠ¡æ˜¯ project ç±»å‹ï¼Œä¹Ÿå°è¯•ä»å…¶æ ‡ç­¾ä¸­æå–è‡ªå®šä¹‰æ ‡ç­¾
                  const parentLabels = parentIssue.data.labels || [];
                  const isProject = parentLabels.some(label => 
                    typeof label === 'string' ? label === 'project' : label.name === 'project'
                  );
                  
                  if (isProject) {
                    // æå–çˆ¶ä»»åŠ¡ä¸­çš„è‡ªå®šä¹‰æ ‡ç­¾ï¼ˆä¸æ˜¯ç³»ç»Ÿé¢„å®šä¹‰çš„æ ‡ç­¾ï¼‰
                    // Note: This system labels list is maintained in .github/tags-config.json
                    // It's hardcoded here for performance (no file read needed at runtime)
                    // When updating tags, update both tags-config.json AND this list
                    const systemLabels = [
                      'project', 'epic', 'task-with-deadline', 'task-open', 'subtask', 'ai-todo-inbox',
                      'priority:critical', 'priority:high', 'priority:medium', 'priority:low',
                      'status:planning', 'status:in-progress', 'status:blocked', 'status:review', 'status:testing',
                      'type:feature', 'type:enhancement', 'type:bug', 'type:refactoring', 'type:documentation', 'type:research',
                      'help-wanted', 'good-first-issue', 'duplicate', 'wontfix', 'archived'
                    ];
                    
                    parentLabels.forEach(label => {
                      const labelName = typeof label === 'string' ? label : label.name;
                      if (!systemLabels.includes(labelName) && !projectLabels.includes(labelName)) {
                        projectLabels.push(labelName);
                        core.info('ä»çˆ¶ä»»åŠ¡æ ‡ç­¾ç»§æ‰¿: ' + labelName);
                      }
                    });
                  }
                  
                  // å°†é¡¹ç›®æ ‡ç­¾æ·»åŠ åˆ°æ–°åˆ›å»ºçš„å­ä»»åŠ¡
                  if (projectLabels.length > 0) {
                    const currentLabels = newIssue.data.labels.map(l => 
                      typeof l === 'string' ? l : l.name
                    );
                    const labelsToAdd = projectLabels.filter(l => !currentLabels.includes(l));
                    
                    if (labelsToAdd.length > 0) {
                      await github.rest.issues.addLabels({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: newIssue.data.number,
                        labels: labelsToAdd
                      });
                      core.info('æˆåŠŸä¸ºå­ä»»åŠ¡æ·»åŠ é¡¹ç›®æ ‡ç­¾: ' + labelsToAdd.join(', '));
                    }
                  }
                  
                  // åœ¨çˆ¶ä»»åŠ¡ä¸­æ·»åŠ å­ä»»åŠ¡é“¾æ¥
                  const subtaskEntry = '- [ ] #' + newIssue.data.number + ' - ' + parsedData.title;
                  
                  // æŸ¥æ‰¾æ˜¯å¦å·²æœ‰å­ä»»åŠ¡åˆ—è¡¨éƒ¨åˆ†
                  let updatedBody;
                  if (parentBody.includes('## ğŸ“ å­ä»»åŠ¡åˆ—è¡¨') || parentBody.includes('## å­ä»»åŠ¡åˆ—è¡¨')) {
                    // åœ¨ç°æœ‰å­ä»»åŠ¡åˆ—è¡¨ä¸­æ·»åŠ æ–°é¡¹
                    const lines = parentBody.split('\n');
                    let insertIndex = -1;
                    let foundSection = false;
                    
                    for (let i = 0; i < lines.length; i++) {
                      if (lines[i].includes('## ğŸ“ å­ä»»åŠ¡åˆ—è¡¨') || lines[i].includes('## å­ä»»åŠ¡åˆ—è¡¨')) {
                        foundSection = true;
                        insertIndex = i + 1;
                        // è·³è¿‡ç©ºè¡Œå’Œç°æœ‰çš„å­ä»»åŠ¡
                        while (insertIndex < lines.length && (lines[insertIndex].trim() === '' || lines[insertIndex].trim().startsWith('- [ ]') || lines[insertIndex].trim().startsWith('- [x]'))) {
                          insertIndex++;
                        }
                        break;
                      }
                    }
                    
                    if (foundSection && insertIndex > 0) {
                      lines.splice(insertIndex, 0, subtaskEntry);
                      updatedBody = lines.join('\n');
                    } else {
                      updatedBody = parentBody + '\n\n## ğŸ“ å­ä»»åŠ¡åˆ—è¡¨\n\n' + subtaskEntry;
                    }
                  } else {
                    // æ·»åŠ æ–°çš„å­ä»»åŠ¡åˆ—è¡¨éƒ¨åˆ†
                    updatedBody = parentBody + '\n\n## ğŸ“ å­ä»»åŠ¡åˆ—è¡¨\n\n' + subtaskEntry;
                  }
                  
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parseInt(parsedData.parent_issue),
                    body: updatedBody
                  });
                  
                  core.info('æˆåŠŸæ›´æ–°çˆ¶ä»»åŠ¡ #' + parsedData.parent_issue);
                } catch (error) {
                  core.warning('æ›´æ–°çˆ¶ä»»åŠ¡å¤±è´¥ï¼š' + error.message);
                  // å³ä½¿æ›´æ–°çˆ¶ä»»åŠ¡å¤±è´¥ï¼Œä¹Ÿç»§ç»­å¤„ç†
                }
              }
              
              // è®°å½•æˆåŠŸåˆ›å»ºçš„ Issue
              createdIssues.push({
                number: newIssue.data.number,
                title: parsedData.title,
                url: newIssue.data.html_url,
                priority: parsedData.priority || 'medium',
                dueDate: parsedData.due_date || 'æ— ',
                parent: parsedData.parent_issue
              });
              
              core.info('æˆåŠŸåˆ›å»º Issue #' + newIssue.data.number);
              
            } catch (error) {
              core.error('åˆ›å»º Issue å¤±è´¥ï¼š' + error.message);
              createdIssues.push({
                error: 'åˆ›å»º Issue å¤±è´¥: ' + error.message,
                input: userInput
              });
            }
            
            } // ç»“æŸæ‰¹é‡åˆ›å»ºå¾ªç¯
            
            // æ‰¹é‡åˆ›å»ºå®Œæˆåï¼Œå‘é€æ±‡æ€»æ¶ˆæ¯
            let summaryMessage = '';
            const successCount = createdIssues.filter(i => !i.error).length;
            const failCount = createdIssues.filter(i => i.error).length;
            
            if (batchCount > 1) {
              // æ‰¹é‡åˆ›å»ºçš„æ±‡æ€»æ¶ˆæ¯
              summaryMessage = 'âœ… **æ‰¹é‡ TODO åˆ›å»ºå®Œæˆï¼**\n\n';
              summaryMessage += 'ğŸ“Š **ç»Ÿè®¡**: æˆåŠŸ ' + successCount + ' ä¸ªï¼Œå¤±è´¥ ' + failCount + ' ä¸ª\n\n';
              
              if (successCount > 0) {
                summaryMessage += '### âœ… æˆåŠŸåˆ›å»ºçš„ TODO\n\n';
                let successIndex = 0;
                createdIssues.forEach((item) => {
                  if (!item.error) {
                    successIndex++;
                    const parentInfo = item.parent ? ' (å­ä»»åŠ¡ #' + item.parent + ')' : '';
                    summaryMessage += successIndex + '. [#' + item.number + '](' + item.url + ') - ' + item.title + parentInfo + '\n';
                  }
                });
              }
              
              if (failCount > 0) {
                summaryMessage += '\n### âŒ åˆ›å»ºå¤±è´¥çš„ TODO\n\n';
                let failIndex = 0;
                createdIssues.forEach((item) => {
                  if (item.error) {
                    failIndex++;
                    summaryMessage += failIndex + '. ' + item.error;
                    if (item.input) {
                      summaryMessage += ' - è¾“å…¥: ' + item.input.substring(0, 50) + '...';
                    }
                    summaryMessage += '\n';
                  }
                });
              }
              
              summaryMessage += '\n---\n\nğŸ’¡ æç¤ºï¼šAI è‡ªåŠ¨è§£æå¯èƒ½ä¸å®Œå…¨å‡†ç¡®ï¼Œè¯·æŸ¥çœ‹å¹¶è¡¥å……å®Œå–„ä¿¡æ¯ã€‚';
            } else if (successCount === 1) {
              // å•ä¸ª TODO åˆ›å»ºçš„æ¶ˆæ¯
              const item = createdIssues[0];
              if (!item.error) {
                const parentInfo = item.parent ? '\nğŸ”— **çˆ¶ä»»åŠ¡**: #' + item.parent : '';
                const milestoneInfo = item.dueDate !== 'æ— ' ? '\nğŸ¯ **Milestone**: å·²å…³è”åˆ°æˆªæ­¢æ—¥æœŸ Milestone' : '';
                summaryMessage = 'âœ… **AI å·²æˆåŠŸåˆ›å»º TODO!**\n\n' +
                  'ğŸ“Œ **æ–° Issue**: #' + item.number + '\n' +
                  'ğŸ“ **æ ‡é¢˜**: ' + item.title + '\n' +
                  'â° **æˆªæ­¢æ—¥æœŸ**: ' + item.dueDate + '\n' +
                  'ğŸ·ï¸ **ä¼˜å…ˆçº§**: ' + item.priority + parentInfo + milestoneInfo + '\n\n' +
                  '[æŸ¥çœ‹è¯¦æƒ… â†’](' + item.url + ')\n\n' +
                  '---\n\n' +
                  'ğŸ’¡ æç¤ºï¼šAI è‡ªåŠ¨è§£æå¯èƒ½ä¸å®Œå…¨å‡†ç¡®ï¼Œè¯·æŸ¥çœ‹å¹¶è¡¥å……å®Œå–„ä¿¡æ¯ã€‚';
              } else {
                summaryMessage = 'âŒ TODO åˆ›å»ºå¤±è´¥: ' + item.error;
              }
            } else {
              summaryMessage = 'âŒ æ‰€æœ‰ TODO åˆ›å»ºå‡å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¾“å…¥æˆ–ç¨åé‡è¯•ã€‚';
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: sourceIssueNumber,
              body: summaryMessage
            });
            
            // å¦‚æœæ˜¯é€šè¿‡ ai-todo-inbox æ ‡ç­¾è§¦å‘çš„ï¼Œä¸”ä¸æ˜¯è¯„è®ºè§¦å‘ï¼Œå…³é—­åŸ Issue
            if (context.eventName === 'issues' && context.payload.issue.labels.some(label => label.name === 'ai-todo-inbox')) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                state: 'closed',
                state_reason: 'completed'
              });
            }
