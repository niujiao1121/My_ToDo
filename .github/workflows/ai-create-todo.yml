name: AI è‡ªåŠ¨åˆ›å»º TODO

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: read

jobs:
  ai-create-todo:
    runs-on: ubuntu-latest
    
    # åªåœ¨ä»¥ä¸‹æƒ…å†µè¿è¡Œï¼š
    # 1. Issue å¸¦æœ‰ ai-todo-inbox æ ‡ç­¾
    # 2. è¯„è®ºä»¥ /todo å¼€å¤´
    if: |
      (github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'ai-todo-inbox')) ||
      (github.event_name == 'issue_comment' && startsWith(github.event.comment.body, '/todo'))
    
    steps:
      - name: æ£€æŸ¥æƒé™
        id: check-permission
        uses: actions/github-script@v7
        with:
          script: |
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ˜¯ä»“åº“æˆå‘˜æˆ–åä½œè€…
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: context.actor
              });
              
              const hasPermission = ['admin', 'write', 'maintain'].includes(permission.permission);
              
              if (!hasPermission) {
                const issueNumber = context.payload.issue.number;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: 'âŒ æŠ±æ­‰ï¼Œåªæœ‰ä»“åº“æˆå‘˜å¯ä»¥ä½¿ç”¨ AI TODO åˆ›å»ºåŠŸèƒ½ã€‚'
                });
                core.setFailed('ç”¨æˆ·æ²¡æœ‰è¶³å¤Ÿçš„æƒé™');
              }
              
              return hasPermission;
            } catch (error) {
              core.error('æ£€æŸ¥æƒé™æ—¶å‡ºé”™ï¼š' + error.message);
              return false;
            }

      - name: AI è§£æå¹¶åˆ›å»º TODO
        if: steps.check-permission.outputs.result == 'true'
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        with:
          script: |
            const https = require('https');
            
            // è·å–ç”¨æˆ·è¾“å…¥
            let userInput = '';
            let sourceIssueNumber = null;
            
            if (context.eventName === 'issues') {
              userInput = context.payload.issue.body || '';
              sourceIssueNumber = context.payload.issue.number;
            } else if (context.eventName === 'issue_comment') {
              const comment = context.payload.comment.body;
              userInput = comment.replace(/^\/todo\s+/, '').trim();
              sourceIssueNumber = context.payload.issue.number;
            }
            
            if (!userInput) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'âŒ è¯·æä¾›è¦åˆ›å»ºçš„ TODO å†…å®¹ã€‚'
              });
              return;
            }
            
            // æ£€æŸ¥ OpenAI API Key
            if (!process.env.OPENAI_API_KEY) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'âŒ OpenAI API Key æœªé…ç½®ã€‚è¯·åœ¨ä»“åº“çš„ Secrets ä¸­æ·»åŠ  `OPENAI_API_KEY`ã€‚\n\né…ç½®æ­¥éª¤ï¼šhttps://github.com/' + context.repo.owner + '/' + context.repo.repo + '/blob/main/docs/AI_SETUP.md'
              });
              return;
            }
            
            // æ„å»º AI æç¤ºè¯
            const currentDate = new Date().toISOString().split('T')[0];
            const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä»»åŠ¡ç®¡ç†åŠ©æ‰‹ã€‚ç”¨æˆ·ä¼šç”¨ä¸­æ–‡æˆ–è‹±æ–‡æè¿°ä¸€ä¸ªä»»åŠ¡ï¼Œä½ éœ€è¦å°†å…¶è§£æä¸ºç»“æ„åŒ–çš„ TODOã€‚

å½“å‰æ—¥æœŸ: ${currentDate}

è¯·åˆ†æç”¨æˆ·è¾“å…¥ï¼Œæå–ä»¥ä¸‹ä¿¡æ¯å¹¶ä»¥ JSON æ ¼å¼è¿”å›ï¼š

{
  "title": "ç®€æ´æ˜äº†çš„ä»»åŠ¡æ ‡é¢˜ï¼ˆ10-50å­—ï¼‰",
  "description": "è¯¦ç»†çš„ä»»åŠ¡æè¿°ï¼ŒåŒ…å«èƒŒæ™¯å’Œå…·ä½“è¦åšçš„äº‹æƒ…",
  "due_date": "æˆªæ­¢æ—¥æœŸ YYYY-MM-DD æ ¼å¼ï¼Œå¦‚æœç”¨æˆ·æåˆ°äº†æ—¥æœŸç›¸å…³çš„è¯ï¼ˆä»Šå¤©ã€æ˜å¤©ã€ä¸‹å‘¨ç­‰ï¼‰åˆ™è®¡ç®—å…·ä½“æ—¥æœŸï¼Œå¦åˆ™ä¸º null",
  "priority": "ä¼˜å…ˆçº§: critical/high/medium/lowï¼Œæ ¹æ®ç”¨æˆ·ç”¨è¯åˆ¤æ–­ï¼ˆç´§æ€¥ã€é‡è¦ç­‰ï¼‰ï¼Œé»˜è®¤ medium",
  "module": "æ¨¡å—ç±»å‹: frontend/backend/database/devops/design/docs/testingï¼Œæ ¹æ®ä»»åŠ¡å†…å®¹æ¨æ–­ï¼Œå¯ä»¥ä¸º null",
  "estimated_hours": "é¢„è®¡å·¥ä½œé‡ï¼ˆå°æ—¶æ•°ï¼‰ï¼Œå¦‚æœç”¨æˆ·æåˆ°äº†å·¥ä½œé‡åˆ™æå–ï¼Œå¦åˆ™æ ¹æ®ä»»åŠ¡å¤æ‚åº¦ä¼°ç®—ï¼Œæ ¼å¼å¦‚ '8' æˆ– '16-24'",
  "acceptance_criteria": ["éªŒæ”¶æ ‡å‡†1", "éªŒæ”¶æ ‡å‡†2"],
  "task_checklist": ["æ­¥éª¤1", "æ­¥éª¤2"],
  "task_type": "ä»»åŠ¡ç±»å‹: deadline æˆ– openï¼Œå¦‚æœæœ‰æˆªæ­¢æ—¥æœŸç”¨ deadlineï¼Œå¦åˆ™ç”¨ open"
}

æ—¥æœŸè¯†åˆ«è§„åˆ™ï¼š
- "ä»Šå¤©" -> ${currentDate}
- "æ˜å¤©" -> å½“å‰æ—¥æœŸ+1å¤©
- "åå¤©" -> å½“å‰æ—¥æœŸ+2å¤©  
- "ä¸‹å‘¨" -> å½“å‰æ—¥æœŸ+7å¤©
- "ä¸‹å‘¨ä¸€/äºŒ/..." -> è®¡ç®—ä¸‹å‘¨å¯¹åº”çš„æ—¥æœŸ
- "ä¸‹æœˆ" -> å½“å‰æ—¥æœŸ+30å¤©
- "æœˆåº•" -> å½“æœˆæœ€åä¸€å¤©
- å…·ä½“æ—¥æœŸå¦‚ "12æœˆ25æ—¥" -> è½¬æ¢ä¸º YYYY-MM-DD

ä¼˜å…ˆçº§åˆ¤æ–­ï¼š
- åŒ…å«"ç´§æ€¥"ã€"urgent"ã€"ASAP"ã€"ç«‹å³" -> critical
- åŒ…å«"é‡è¦"ã€"high"ã€"å…³é”®" -> high  
- åŒ…å«"ä¸€èˆ¬"ã€"normal"ã€"medium" -> medium
- åŒ…å«"ä¸æ€¥"ã€"low"ã€"å¯é€‰" -> low
- é»˜è®¤ -> medium

æ¨¡å—æ¨æ–­ï¼š
- åŒ…å«"å‰ç«¯"ã€"UI"ã€"é¡µé¢"ã€"React"ã€"Vue" -> frontend
- åŒ…å«"åç«¯"ã€"API"ã€"æœåŠ¡å™¨"ã€"æ•°æ®åº“" -> backend
- åŒ…å«"æ•°æ®åº“"ã€"SQL"ã€"MongoDB" -> database
- åŒ…å«"éƒ¨ç½²"ã€"CI/CD"ã€"Docker" -> devops
- åŒ…å«"è®¾è®¡"ã€"UIè®¾è®¡"ã€"åŸå‹" -> design
- åŒ…å«"æ–‡æ¡£"ã€"è¯´æ˜" -> docs
- åŒ…å«"æµ‹è¯•" -> testing

åªè¿”å› JSONï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—ã€‚`;

            const userPrompt = `ç”¨æˆ·è¾“å…¥ï¼š\n${userInput}`;
            
            // è°ƒç”¨ OpenAI API
            let aiResponse;
            try {
              const postData = JSON.stringify({
                model: 'gpt-4o-mini',
                messages: [
                  { role: 'system', content: systemPrompt },
                  { role: 'user', content: userPrompt }
                ],
                temperature: 0.3,
                response_format: { type: 'json_object' }
              });
              
              const options = {
                hostname: 'api.openai.com',
                path: '/v1/chat/completions',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                  'Content-Length': Buffer.byteLength(postData)
                }
              };
              
              aiResponse = await new Promise((resolve, reject) => {
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', (chunk) => { data += chunk; });
                  res.on('end', () => {
                    if (res.statusCode === 200) {
                      resolve(JSON.parse(data));
                    } else {
                      reject(new Error(`API è¯·æ±‚å¤±è´¥: ${res.statusCode} - ${data}`));
                    }
                  });
                });
                
                req.on('error', (error) => reject(error));
                req.write(postData);
                req.end();
              });
              
              core.info('OpenAI API å“åº”ï¼š' + JSON.stringify(aiResponse));
              
            } catch (error) {
              core.error('è°ƒç”¨ OpenAI API å¤±è´¥ï¼š' + error.message);
              
              // å¤±è´¥æ—¶ä½¿ç”¨åŸºæœ¬ä¿¡æ¯åˆ›å»º Issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: `âŒ AI è§£æå¤±è´¥ï¼š${error.message}\n\nå°†ä½¿ç”¨åŸºæœ¬ä¿¡æ¯åˆ›å»º TODO...`
              });
              
              // åˆ›å»ºç®€å•çš„ Issue
              const basicIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '[TODO] ' + userInput.substring(0, 50),
                body: `## ğŸ“‹ ä»»åŠ¡æè¿°\n\n${userInput}\n\n---\n\n*æ­¤ TODO ç”± AI åŠ©æ‰‹è‡ªåŠ¨åˆ›å»º*`,
                labels: ['task-open', 'priority:medium'],
                assignees: [context.actor]
              });
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: `âœ… å·²åˆ›å»ºåŸºæœ¬ TODO: #${basicIssue.data.number}`
              });
              
              return;
            }
            
            // è§£æ AI å“åº”
            let parsedData;
            try {
              const content = aiResponse.choices[0].message.content;
              parsedData = JSON.parse(content);
              core.info('è§£æåçš„æ•°æ®ï¼š' + JSON.stringify(parsedData));
            } catch (error) {
              core.error('è§£æ AI å“åº”å¤±è´¥ï¼š' + error.message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: `âŒ è§£æ AI å“åº”å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚`
              });
              return;
            }
            
            // æ„å»º Issue å†…å®¹
            const taskType = parsedData.task_type === 'deadline' ? 'task-with-deadline' : 'task-open';
            const titlePrefix = taskType === 'task-with-deadline' ? '[TASK]' : '[OPEN]';
            
            let issueBody = '';
            
            if (taskType === 'task-with-deadline') {
              // æœ‰æˆªæ­¢æ—¥æœŸçš„ä»»åŠ¡æ¨¡æ¿
              issueBody = `## ğŸ“‹ ä»»åŠ¡æè¿°

${parsedData.description}

## â° æ—¶é—´è¦æ±‚

**æˆªæ­¢æ—¥æœŸ**: ${parsedData.due_date || 'å¾…å®š'} â°
**é¢„è®¡å·¥ä½œé‡**: ${parsedData.estimated_hours || 'å¾…è¯„ä¼°'}å°æ—¶

## âœ… éªŒæ”¶æ ‡å‡†

${parsedData.acceptance_criteria && parsedData.acceptance_criteria.length > 0 
  ? parsedData.acceptance_criteria.map(c => `- [ ] ${c}`).join('\n')
  : '- [ ] å¾…è¡¥å……'}

## ğŸ“ ä»»åŠ¡æ¸…å•

${parsedData.task_checklist && parsedData.task_checklist.length > 0
  ? parsedData.task_checklist.map(t => `- [ ] ${t}`).join('\n')
  : '- [ ] å¾…è¡¥å……'}

---

*æ­¤ TODO ç”± AI åŠ©æ‰‹æ ¹æ®è¾“å…¥è‡ªåŠ¨åˆ›å»º*
*åŸå§‹è¾“å…¥æ¥è‡ª: #${sourceIssueNumber}*`;
            } else {
              // å¼€æ”¾æ€§ä»»åŠ¡æ¨¡æ¿
              issueBody = `## ğŸ“‹ ä»»åŠ¡æè¿°

${parsedData.description}

## ğŸ¯ å®Œæˆæ¡ä»¶

**é¢„è®¡å·¥ä½œé‡**: ${parsedData.estimated_hours || 'å¾…è¯„ä¼°'}å°æ—¶

**éªŒæ”¶æ ‡å‡†**: 
${parsedData.acceptance_criteria && parsedData.acceptance_criteria.length > 0 
  ? parsedData.acceptance_criteria.map(c => `- [ ] ${c}`).join('\n')
  : '- [ ] å¾…è¡¥å……'}

## ğŸ“ å®ç°æ€è·¯

${parsedData.task_checklist && parsedData.task_checklist.length > 0
  ? parsedData.task_checklist.map((t, i) => `${i + 1}. ${t}`).join('\n')
  : 'å¾…è¡¥å……'}

---

*æ­¤ TODO ç”± AI åŠ©æ‰‹æ ¹æ®è¾“å…¥è‡ªåŠ¨åˆ›å»º*
*åŸå§‹è¾“å…¥æ¥è‡ª: #${sourceIssueNumber}*`;
            }
            
            // ç¡®å®šæ ‡ç­¾
            const labels = [taskType, `priority:${parsedData.priority || 'medium'}`];
            if (parsedData.module) {
              labels.push(`module:${parsedData.module}`);
            }
            
            // åˆ›å»ºæ–° Issue
            try {
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `${titlePrefix} ${parsedData.title}`,
                body: issueBody,
                labels: labels,
                assignees: [context.actor]
              });
              
              // å›å¤æˆåŠŸæ¶ˆæ¯
              const successMessage = `âœ… **AI å·²æˆåŠŸåˆ›å»º TODO!**

ğŸ“Œ **æ–° Issue**: #${newIssue.data.number}
ğŸ“ **æ ‡é¢˜**: ${parsedData.title}
â° **æˆªæ­¢æ—¥æœŸ**: ${parsedData.due_date || 'æ— '}
ğŸ·ï¸ **ä¼˜å…ˆçº§**: ${parsedData.priority || 'medium'}
${parsedData.module ? `ğŸ“¦ **æ¨¡å—**: ${parsedData.module}` : ''}

[æŸ¥çœ‹è¯¦æƒ… â†’](${newIssue.data.html_url})

---

ğŸ’¡ æç¤ºï¼šAI è‡ªåŠ¨è§£æå¯èƒ½ä¸å®Œå…¨å‡†ç¡®ï¼Œè¯·æŸ¥çœ‹å¹¶è¡¥å……å®Œå–„ä¿¡æ¯ã€‚`;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: successMessage
              });
              
              // å¦‚æœæ˜¯é€šè¿‡ ai-todo-inbox æ ‡ç­¾è§¦å‘çš„ï¼Œå…³é—­åŸ Issue
              if (context.eventName === 'issues' && context.payload.action === 'labeled') {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: sourceIssueNumber,
                  state: 'closed',
                  state_reason: 'completed'
                });
              }
              
              core.info(`æˆåŠŸåˆ›å»º Issue #${newIssue.data.number}`);
              
            } catch (error) {
              core.error('åˆ›å»º Issue å¤±è´¥ï¼š' + error.message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: `âŒ åˆ›å»º Issue å¤±è´¥ï¼š${error.message}`
              });
            }
