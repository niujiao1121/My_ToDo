name: AI è‡ªåŠ¨åˆ›å»º TODO

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: read

jobs:
  ai-create-todo:
    runs-on: ubuntu-latest
    
    # åªåœ¨ä»¥ä¸‹æƒ…å†µè¿è¡Œï¼š
    # 1. Issue å¸¦æœ‰ ai-todo-inbox æ ‡ç­¾
    # 2. è¯„è®ºä»¥ /todo å¼€å¤´
    if: |
      (github.event_name == 'issues' && contains(github.event.issue.labels.*.name, 'ai-todo-inbox')) ||
      (github.event_name == 'issue_comment' && startsWith(github.event.comment.body, '/todo'))
    
    steps:
      - name: æ£€æŸ¥æƒé™
        id: check-permission
        uses: actions/github-script@v7
        with:
          script: |
            // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ˜¯ä»“åº“æˆå‘˜æˆ–åä½œè€…
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: context.actor
              });
              
              const hasPermission = ['admin', 'write', 'maintain'].includes(permission.permission);
              
              if (!hasPermission) {
                const issueNumber = context.payload.issue.number;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: 'âŒ æŠ±æ­‰ï¼Œåªæœ‰ä»“åº“æˆå‘˜å¯ä»¥ä½¿ç”¨ AI TODO åˆ›å»ºåŠŸèƒ½ã€‚'
                });
                core.setFailed('ç”¨æˆ·æ²¡æœ‰è¶³å¤Ÿçš„æƒé™');
              }
              
              return hasPermission;
            } catch (error) {
              core.error('æ£€æŸ¥æƒé™æ—¶å‡ºé”™ï¼š' + error.message);
              return false;
            }

      - name: AI è§£æå¹¶åˆ›å»º TODO
        if: steps.check-permission.outputs.result == 'true'
        uses: actions/github-script@v7
        env:
          DASHSCOPE_API_KEY: ${{ secrets.DASHSCOPE_API_KEY }}
        with:
          script: |
            const https = require('https');
            
            // è·å–ç”¨æˆ·è¾“å…¥
            let userInput = '';
            let sourceIssueNumber = null;
            
            if (context.eventName === 'issues') {
              userInput = context.payload.issue.body || '';
              sourceIssueNumber = context.payload.issue.number;
            } else if (context.eventName === 'issue_comment') {
              const comment = context.payload.comment.body;
              userInput = comment.replace(/^\/todo\s+/, '').trim();
              sourceIssueNumber = context.payload.issue.number;
            }
            
            if (!userInput) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'âŒ è¯·æä¾›è¦åˆ›å»ºçš„ TODO å†…å®¹ã€‚'
              });
              return;
            }
            
            // æ£€æŸ¥é˜¿é‡Œäº‘ API Key
            if (!process.env.DASHSCOPE_API_KEY) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'âŒ é˜¿é‡Œäº‘ API Key æœªé…ç½®ã€‚è¯·åœ¨ä»“åº“çš„ Secrets ä¸­æ·»åŠ  `DASHSCOPE_API_KEY`ã€‚\n\né…ç½®æ­¥éª¤ï¼šhttps://github.com/' + context.repo.owner + '/' + context.repo.repo + '/blob/main/docs/AI_SETUP.md'
              });
              return;
            }
            
            // æ„å»º AI æç¤ºè¯
            // Note: ä½¿ç”¨å­—ç¬¦ä¸²æ‹¼æ¥è€Œéæ¨¡æ¿å­—é¢é‡ä»¥é¿å… YAML è§£æé—®é¢˜
            const currentDate = new Date().toISOString().split('T')[0];
            const systemPrompt = 'ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä»»åŠ¡ç®¡ç†åŠ©æ‰‹ã€‚ç”¨æˆ·ä¼šç”¨ä¸­æ–‡æˆ–è‹±æ–‡æè¿°ä¸€ä¸ªä»»åŠ¡ï¼Œä½ éœ€è¦å°†å…¶è§£æä¸ºç»“æ„åŒ–çš„ TODOã€‚\n\n' +
              'å½“å‰æ—¥æœŸ: ' + currentDate + '\n\n' +
              'è¯·åˆ†æç”¨æˆ·è¾“å…¥ï¼Œæå–ä»¥ä¸‹ä¿¡æ¯å¹¶ä»¥ JSON æ ¼å¼è¿”å›ï¼š\n\n' +
              '{\n' +
              '  "title": "ç®€æ´æ˜äº†çš„ä»»åŠ¡æ ‡é¢˜ï¼ˆ10-50å­—ï¼‰",\n' +
              '  "description": "è¯¦ç»†çš„ä»»åŠ¡æè¿°ï¼ŒåŒ…å«èƒŒæ™¯å’Œå…·ä½“è¦åšçš„äº‹æƒ…",\n' +
              '  "due_date": "æˆªæ­¢æ—¥æœŸ YYYY-MM-DD æ ¼å¼ï¼Œå¦‚æœç”¨æˆ·æåˆ°äº†æ—¥æœŸç›¸å…³çš„è¯ï¼ˆä»Šå¤©ã€æ˜å¤©ã€ä¸‹å‘¨ç­‰ï¼‰åˆ™è®¡ç®—å…·ä½“æ—¥æœŸï¼Œå¦åˆ™ä¸º null",\n' +
              '  "priority": "ä¼˜å…ˆçº§: critical/high/medium/lowï¼Œæ ¹æ®ç”¨æˆ·ç”¨è¯åˆ¤æ–­ï¼ˆç´§æ€¥ã€é‡è¦ç­‰ï¼‰ï¼Œé»˜è®¤ medium",\n' +
              '  "module": "æ¨¡å—ç±»å‹: frontend/backend/database/devops/design/docs/testingï¼Œæ ¹æ®ä»»åŠ¡å†…å®¹æ¨æ–­ï¼Œå¯ä»¥ä¸º null",\n' +
              '  "estimated_hours": "é¢„è®¡å·¥ä½œé‡ï¼ˆå°æ—¶æ•°ï¼‰ï¼Œå¦‚æœç”¨æˆ·æåˆ°äº†å·¥ä½œé‡åˆ™æå–ï¼Œå¦åˆ™æ ¹æ®ä»»åŠ¡å¤æ‚åº¦ä¼°ç®—ï¼Œæ ¼å¼å¦‚ \'8\' æˆ– \'16-24\'",\n' +
              '  "acceptance_criteria": ["éªŒæ”¶æ ‡å‡†1", "éªŒæ”¶æ ‡å‡†2"],\n' +
              '  "task_checklist": ["æ­¥éª¤1", "æ­¥éª¤2"],\n' +
              '  "task_type": "ä»»åŠ¡ç±»å‹: deadline æˆ– openï¼Œå¦‚æœæœ‰æˆªæ­¢æ—¥æœŸç”¨ deadlineï¼Œå¦åˆ™ç”¨ open"\n' +
              '}\n\n' +
              'æ—¥æœŸè¯†åˆ«è§„åˆ™ï¼š\n' +
              '- "ä»Šå¤©" -> ' + currentDate + '\n' +
              '- "æ˜å¤©" -> å½“å‰æ—¥æœŸ+1å¤©\n' +
              '- "åå¤©" -> å½“å‰æ—¥æœŸ+2å¤©\n' +
              '- "ä¸‹å‘¨" -> å½“å‰æ—¥æœŸ+7å¤©\n' +
              '- "ä¸‹å‘¨ä¸€/äºŒ/..." -> è®¡ç®—ä¸‹å‘¨å¯¹åº”çš„æ—¥æœŸ\n' +
              '- "ä¸‹æœˆ" -> å½“å‰æ—¥æœŸ+30å¤©\n' +
              '- "æœˆåº•" -> å½“æœˆæœ€åä¸€å¤©\n' +
              '- å…·ä½“æ—¥æœŸå¦‚ "12æœˆ25æ—¥" -> è½¬æ¢ä¸º YYYY-MM-DD\n\n' +
              'ä¼˜å…ˆçº§åˆ¤æ–­ï¼š\n' +
              '- åŒ…å«"ç´§æ€¥"ã€"urgent"ã€"ASAP"ã€"ç«‹å³" -> critical\n' +
              '- åŒ…å«"é‡è¦"ã€"high"ã€"å…³é”®" -> high\n' +
              '- åŒ…å«"ä¸€èˆ¬"ã€"normal"ã€"medium" -> medium\n' +
              '- åŒ…å«"ä¸æ€¥"ã€"low"ã€"å¯é€‰" -> low\n' +
              '- é»˜è®¤ -> medium\n\n' +
              'æ¨¡å—æ¨æ–­ï¼š\n' +
              '- åŒ…å«"å‰ç«¯"ã€"UI"ã€"é¡µé¢"ã€"React"ã€"Vue" -> frontend\n' +
              '- åŒ…å«"åç«¯"ã€"API"ã€"æœåŠ¡å™¨"ã€"æ•°æ®åº“" -> backend\n' +
              '- åŒ…å«"æ•°æ®åº“"ã€"SQL"ã€"MongoDB" -> database\n' +
              '- åŒ…å«"éƒ¨ç½²"ã€"CI/CD"ã€"Docker" -> devops\n' +
              '- åŒ…å«"è®¾è®¡"ã€"UIè®¾è®¡"ã€"åŸå‹" -> design\n' +
              '- åŒ…å«"æ–‡æ¡£"ã€"è¯´æ˜" -> docs\n' +
              '- åŒ…å«"æµ‹è¯•" -> testing\n\n' +
              'åªè¿”å› JSONï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—ã€‚';

            const userPrompt = 'ç”¨æˆ·è¾“å…¥ï¼š\n' + userInput;
            
            // è°ƒç”¨é˜¿é‡Œäº‘åƒé—® API
            let aiResponse;
            try {
              const postData = JSON.stringify({
                model: 'qwen-plus',
                messages: [
                  { role: 'system', content: systemPrompt },
                  { role: 'user', content: userPrompt }
                ],
                temperature: 0.3,
                response_format: { type: 'json_object' }
              });
              
              const options = {
                hostname: 'dashscope.aliyuncs.com',
                path: '/compatible-mode/v1/chat/completions',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': 'Bearer ' + process.env.DASHSCOPE_API_KEY,
                  'Content-Length': Buffer.byteLength(postData)
                }
              };
              
              aiResponse = await new Promise((resolve, reject) => {
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', (chunk) => { data += chunk; });
                  res.on('end', () => {
                    if (res.statusCode === 200) {
                      resolve(JSON.parse(data));
                    } else {
                      reject(new Error('API è¯·æ±‚å¤±è´¥: ' + res.statusCode + ' - ' + data));
                    }
                  });
                });
                
                req.on('error', (error) => reject(error));
                req.write(postData);
                req.end();
              });
              
              core.info('é˜¿é‡Œäº‘ API å“åº”ï¼š' + JSON.stringify(aiResponse));
              
            } catch (error) {
              core.error('è°ƒç”¨é˜¿é‡Œäº‘ API å¤±è´¥ï¼š' + error.message);
              
              // å¤±è´¥æ—¶ä½¿ç”¨åŸºæœ¬ä¿¡æ¯åˆ›å»º Issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'âŒ AI è§£æå¤±è´¥ï¼š' + error.message + '\n\nå°†ä½¿ç”¨åŸºæœ¬ä¿¡æ¯åˆ›å»º TODO...'
              });
              
              // åˆ›å»ºç®€å•çš„ Issue
              const basicIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '[TODO] ' + userInput.substring(0, 50),
                body: '## ğŸ“‹ ä»»åŠ¡æè¿°\n\n' + userInput + '\n\n---\n\n*æ­¤ TODO ç”± AI åŠ©æ‰‹è‡ªåŠ¨åˆ›å»º*',
                labels: ['task-open', 'priority:medium'],
                assignees: [context.actor]
              });
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'âœ… å·²åˆ›å»ºåŸºæœ¬ TODO: #' + basicIssue.data.number
              });
              
              return;
            }
            
            // è§£æ AI å“åº”
            let parsedData;
            try {
              const content = aiResponse.choices[0].message.content;
              parsedData = JSON.parse(content);
              core.info('è§£æåçš„æ•°æ®ï¼š' + JSON.stringify(parsedData));
            } catch (error) {
              core.error('è§£æ AI å“åº”å¤±è´¥ï¼š' + error.message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'âŒ è§£æ AI å“åº”å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚'
              });
              return;
            }
            
            // æ„å»º Issue å†…å®¹
            const taskType = parsedData.task_type === 'deadline' ? 'task-with-deadline' : 'task-open';
            const titlePrefix = taskType === 'task-with-deadline' ? '[TASK]' : '[OPEN]';
            
            let issueBody = '';
            
            if (taskType === 'task-with-deadline') {
              // æœ‰æˆªæ­¢æ—¥æœŸçš„ä»»åŠ¡æ¨¡æ¿
              const acceptanceCriteria = parsedData.acceptance_criteria && parsedData.acceptance_criteria.length > 0 
                ? parsedData.acceptance_criteria.map(c => '- [ ] ' + c).join('\n')
                : '- [ ] å¾…è¡¥å……';
              const taskChecklist = parsedData.task_checklist && parsedData.task_checklist.length > 0
                ? parsedData.task_checklist.map(t => '- [ ] ' + t).join('\n')
                : '- [ ] å¾…è¡¥å……';
              
              issueBody = '## ğŸ“‹ ä»»åŠ¡æè¿°\n\n' + parsedData.description + '\n\n' +
                '## â° æ—¶é—´è¦æ±‚\n\n' +
                '**æˆªæ­¢æ—¥æœŸ**: ' + (parsedData.due_date || 'å¾…å®š') + ' â°\n' +
                '**é¢„è®¡å·¥ä½œé‡**: ' + (parsedData.estimated_hours || 'å¾…è¯„ä¼°') + 'å°æ—¶\n\n' +
                '## âœ… éªŒæ”¶æ ‡å‡†\n\n' + acceptanceCriteria + '\n\n' +
                '## ğŸ“ ä»»åŠ¡æ¸…å•\n\n' + taskChecklist + '\n\n' +
                '---\n\n' +
                '*æ­¤ TODO ç”±é˜¿é‡Œäº‘ AI åŠ©æ‰‹æ ¹æ®è¾“å…¥è‡ªåŠ¨åˆ›å»º*\n' +
                '*åŸå§‹è¾“å…¥æ¥è‡ª: #' + sourceIssueNumber + '*';
            } else {
              // å¼€æ”¾æ€§ä»»åŠ¡æ¨¡æ¿
              const acceptanceCriteria = parsedData.acceptance_criteria && parsedData.acceptance_criteria.length > 0 
                ? parsedData.acceptance_criteria.map(c => '- [ ] ' + c).join('\n')
                : '- [ ] å¾…è¡¥å……';
              const taskChecklist = parsedData.task_checklist && parsedData.task_checklist.length > 0
                ? parsedData.task_checklist.map((t, i) => (i + 1) + '. ' + t).join('\n')
                : 'å¾…è¡¥å……';
              
              issueBody = '## ğŸ“‹ ä»»åŠ¡æè¿°\n\n' + parsedData.description + '\n\n' +
                '## ğŸ¯ å®Œæˆæ¡ä»¶\n\n' +
                '**é¢„è®¡å·¥ä½œé‡**: ' + (parsedData.estimated_hours || 'å¾…è¯„ä¼°') + 'å°æ—¶\n\n' +
                '**éªŒæ”¶æ ‡å‡†**: \n' + acceptanceCriteria + '\n\n' +
                '## ğŸ“ å®ç°æ€è·¯\n\n' + taskChecklist + '\n\n' +
                '---\n\n' +
                '*æ­¤ TODO ç”±é˜¿é‡Œäº‘ AI åŠ©æ‰‹æ ¹æ®è¾“å…¥è‡ªåŠ¨åˆ›å»º*\n' +
                '*åŸå§‹è¾“å…¥æ¥è‡ª: #' + sourceIssueNumber + '*';
            }
            
            // ç¡®å®šæ ‡ç­¾
            const labels = [taskType, 'priority:' + (parsedData.priority || 'medium')];
            if (parsedData.module) {
              labels.push('module:' + parsedData.module);
            }
            
            // åˆ›å»ºæ–° Issue
            try {
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: titlePrefix + ' ' + parsedData.title,
                body: issueBody,
                labels: labels,
                assignees: [context.actor]
              });
              
              // å›å¤æˆåŠŸæ¶ˆæ¯
              const moduleInfo = parsedData.module ? '\nğŸ“¦ **æ¨¡å—**: ' + parsedData.module : '';
              const successMessage = 'âœ… **AI å·²æˆåŠŸåˆ›å»º TODO!**\n\n' +
                'ğŸ“Œ **æ–° Issue**: #' + newIssue.data.number + '\n' +
                'ğŸ“ **æ ‡é¢˜**: ' + parsedData.title + '\n' +
                'â° **æˆªæ­¢æ—¥æœŸ**: ' + (parsedData.due_date || 'æ— ') + '\n' +
                'ğŸ·ï¸ **ä¼˜å…ˆçº§**: ' + (parsedData.priority || 'medium') + moduleInfo + '\n\n' +
                '[æŸ¥çœ‹è¯¦æƒ… â†’](' + newIssue.data.html_url + ')\n\n' +
                '---\n\n' +
                'ğŸ’¡ æç¤ºï¼šAI è‡ªåŠ¨è§£æå¯èƒ½ä¸å®Œå…¨å‡†ç¡®ï¼Œè¯·æŸ¥çœ‹å¹¶è¡¥å……å®Œå–„ä¿¡æ¯ã€‚';
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: successMessage
              });
              
              // å¦‚æœæ˜¯é€šè¿‡ ai-todo-inbox æ ‡ç­¾è§¦å‘çš„ï¼Œä¸”ä¸æ˜¯è¯„è®ºè§¦å‘ï¼Œå…³é—­åŸ Issue
              if (context.eventName === 'issues' && context.payload.issue.labels.some(label => label.name === 'ai-todo-inbox')) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: sourceIssueNumber,
                  state: 'closed',
                  state_reason: 'completed'
                });
              }
              
              core.info('æˆåŠŸåˆ›å»º Issue #' + newIssue.data.number);
              
            } catch (error) {
              core.error('åˆ›å»º Issue å¤±è´¥ï¼š' + error.message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: sourceIssueNumber,
                body: 'âŒ åˆ›å»º Issue å¤±è´¥ï¼š' + error.message
              });
            }
